<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Cursor AI Development Test</title>
      <link href="//Shader/cursor-ai-development-test/"/>
      <url>//Shader/cursor-ai-development-test/</url>
      
        <content type="html"><![CDATA[<h1 id="Cursor-AI-Development-Test"><a href="#Cursor-AI-Development-Test" class="headerlink" title="Cursor AI Development Test"></a>Cursor AI Development Test</h1><p>Brief introduction explaining what readers will learn…</p><span id="more"></span><h2 id="Basic-Concepts"><a href="#Basic-Concepts" class="headerlink" title="Basic Concepts"></a>Basic Concepts</h2><p>Before we start, we need to understand some basic concepts…</p><h2 id="Implementation-Steps"><a href="#Implementation-Steps" class="headerlink" title="Implementation Steps"></a>Implementation Steps</h2><h3 id="Step-1-Preparation"><a href="#Step-1-Preparation" class="headerlink" title="Step 1: Preparation"></a>Step 1: Preparation</h3><p>Detailed explanation of the first step…</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// Example code</span><br><span class="line">Shader &quot;Custom/ExampleShader&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainTex (&quot;Texture&quot;, 2D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Step-2-Core-Implementation"><a href="#Step-2-Core-Implementation" class="headerlink" title="Step 2: Core Implementation"></a>Step 2: Core Implementation</h3><p>Continue with the next step implementation…</p><h2 id="Practical-Application"><a href="#Practical-Application" class="headerlink" title="Practical Application"></a>Practical Application</h2><p>How to apply this knowledge in real projects…</p><h2 id="Next-Steps"><a href="#Next-Steps" class="headerlink" title="Next Steps"></a>Next Steps</h2><ul><li><a href="/Shader/Shader000/" title="Shader 学习大纲">Shader 学习大纲</a></li><li><a href="/Shader/Shader001/" title="Shader 常用参数">Shader 常用参数</a></li></ul><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ol><li><a href="https://docs.unity3d.com/">Unity Documentation</a></li><li><a href="https://docs.unity3d.com/Manual/SL-Reference.html">Shader Reference</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Shader </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shader </tag>
            
            <tag> Tutorial </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MarkDown学习</title>
      <link href="//Markdown/"/>
      <url>//Markdown/</url>
      
        <content type="html"><![CDATA[<p>Markdown 是一种轻量级的标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成结构化的 HTML 页面。它的目标是实现“易读易写”，并且具有一定的可读性，即使在没有格式转换的情况下也能被阅读。</p><p>以下是 Markdown 的一些基本语法：</p><h2 id="标题：使用井号-表示不同级别的标题。"><a href="#标题：使用井号-表示不同级别的标题。" class="headerlink" title="标题：使用井号 # 表示不同级别的标题。"></a><strong>标题</strong>：使用井号 <code>#</code> 表示不同级别的标题。</h2>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 这是一级标题</span><br><span class="line">## 这是二级标题</span><br><span class="line">### 这是三级标题</span><br></pre></td></tr></table></figure><hr><h2 id="强调：使用星号-或下划线-来强调文本。"><a href="#强调：使用星号-或下划线-来强调文本。" class="headerlink" title="强调：使用星号 * 或下划线 _ 来强调文本。"></a><strong>强调</strong>：使用星号 <code>*</code> 或下划线 <code>_</code> 来强调文本。</h2>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*这是斜体文本*</span><br><span class="line">_这也是斜体文本_</span><br><span class="line">**这是加粗文本**</span><br><span class="line">__这也是加粗文本__</span><br></pre></td></tr></table></figure><p>   <em>这是斜体文本</em><br>   <em>这也是斜体文本</em><br>   <strong>这是加粗文本</strong><br>   <strong>这也是加粗文本</strong>  </p><hr><h2 id="列表："><a href="#列表：" class="headerlink" title="列表："></a><strong>列表</strong>：</h2><ol><li>无序列表使用星号 <code>*</code>、加号 <code>+</code> 或减号 <code>-</code> 来创建。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* 列表项一</span><br><span class="line">* 列表项二</span><br><span class="line">* 列表项三</span><br></pre></td></tr></table></figure><ul><li>列表项一</li><li>列表项二</li><li>列表项三</li></ul></li><li>有序列表使用数字后跟一个点来创建。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 第一项</span><br><span class="line">2. 第二项</span><br><span class="line">3. 第三项</span><br></pre></td></tr></table></figure><ol><li>第一项</li><li>第二项</li><li>第三项</li></ol></li></ol><hr><h2 id="链接：使用方括号和圆括号来创建链接。"><a href="#链接：使用方括号和圆括号来创建链接。" class="headerlink" title="链接：使用方括号和圆括号来创建链接。"></a><strong>链接</strong>：使用方括号和圆括号来创建链接。</h2>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[这是一个链接](https://alunworker.com)</span><br></pre></td></tr></table></figure><p>   <a href="https://alunworker.com/">这是一个链接</a></p><hr><h2 id="图片：使用感叹号和方括号来创建图片。"><a href="#图片：使用感叹号和方括号来创建图片。" class="headerlink" title="图片：使用感叹号和方括号来创建图片。"></a><strong>图片</strong>：使用感叹号和方括号来创建图片。</h2>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![这是图片的alt文字](https://alunworker.com/images/favicon.webp)</span><br></pre></td></tr></table></figure><p>   <img src="https://alunworker.com/images/favicon.webp" alt="这是图片的alt文字"></p><hr><h2 id="代码：使用反引号来创建行内代码，或者使用三个反引号来创建一个代码块。"><a href="#代码：使用反引号来创建行内代码，或者使用三个反引号来创建一个代码块。" class="headerlink" title="代码：使用反引号来创建行内代码，或者使用三个反引号来创建一个代码块。"></a><strong>代码</strong>：使用反引号来创建行内代码，或者使用三个反引号来创建一个代码块。</h2>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">`这是行内代码`</span><br><span class="line">&#x27;```&#x27;</span><br><span class="line">&#x27;```&#x27;</span><br><span class="line">&#x27;```&#x27;</span><br><span class="line">&#x27;这是代码块&#x27;</span><br></pre></td></tr></table></figure><hr><h2 id="引用：使用大于号-来创建引用文本。"><a href="#引用：使用大于号-来创建引用文本。" class="headerlink" title="引用：使用大于号 &gt; 来创建引用文本。"></a><strong>引用</strong>：使用大于号 <code>&gt;</code> 来创建引用文本。</h2>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; 这是一段引用文本</span><br></pre></td></tr></table></figure><blockquote><p>这是一段引用文本</p></blockquote><h2 id="水平线：使用三个星号-或三个减号-来创建水平线。"><a href="#水平线：使用三个星号-或三个减号-来创建水平线。" class="headerlink" title="水平线：使用三个星号 *** 或三个减号 --- 来创建水平线。"></a><strong>水平线</strong>：使用三个星号 <code>***</code> 或三个减号 <code>---</code> 来创建水平线。</h2>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">***</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">或</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">***</span><br></pre></td></tr></table></figure><hr><hr><h2 id="表格：使用管道符-和连字符-来创建表格。"><a href="#表格：使用管道符-和连字符-来创建表格。" class="headerlink" title="表格：使用管道符 | 和连字符 - 来创建表格。"></a><strong>表格</strong>：使用管道符 <code>|</code> 和连字符 <code>-</code> 来创建表格。</h2>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">| 标题1 | 标题2 | 标题3 |</span><br><span class="line">|-------|-------|-------|</span><br><span class="line">| 单元格1 | 单元格2 | 单元格3 |</span><br><span class="line">| 单元格4 | 单元格5 | 单元格6 |</span><br></pre></td></tr></table></figure><table><thead><tr><th>标题1</th><th>标题2</th><th>标题3</th></tr></thead><tbody><tr><td>单元格1</td><td>单元格2</td><td>单元格3</td></tr><tr><td>单元格4</td><td>单元格5</td><td>单元格6</td></tr></tbody></table><hr><h2 id="换行显示：加两个空格。"><a href="#换行显示：加两个空格。" class="headerlink" title="换行显示：加两个空格。"></a><strong>换行显示</strong>：加两个空格。</h2>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这是第一行。··</span><br><span class="line">这是第二行。</span><br><span class="line">注意：在上面的示例中，·· 代表两个空格。在实际使用中，你只需要在行尾添加两个空格然后换行。</span><br></pre></td></tr></table></figure><p>   这是第一行。<br>   这是第二行。</p><hr>]]></content>
      
      
      <categories>
          
          <category> MarkDown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MarkDown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shader 学习大纲</title>
      <link href="//Shader/Shader000/"/>
      <url>//Shader/Shader000/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>学习Shader对于游戏程序开发有很多好处，以下是一些主要原因：</p><ol><li><strong>提高渲染效率</strong>：Shader是运行在GPU上的程序，可以高效地处理图形渲染任务，比CPU更快。</li><li><strong>定制化渲染效果</strong>：通过编写Shader，开发者可以创建独特的视觉效果，如复杂的光照模型、动态阴影、高级后处理效果等。</li><li><strong>优化性能</strong>：Shader编程可以帮助开发者优化游戏性能，通过减少CPU和GPU之间的数据传输，降低延迟。</li><li><strong>跨平台兼容性</strong>：Shader语言如GLSL和HLSL等在不同的平台和设备上具有很好的兼容性，有助于游戏的多平台发布。</li><li><strong>增强视觉效果</strong>：Shader可以创建逼真的视觉效果，提高游戏的视觉效果和玩家的沉浸感。</li><li><strong>提升专业技能</strong>：掌握Shader编程可以提升开发者的专业技能，使他们能够解决更复杂的图形问题。</li><li><strong>创新和实验</strong>：Shader提供了一个实验和创新的平台，开发者可以尝试新的技术，推动图形技术的发展。</li><li><strong>职业发展</strong>：在游戏行业，对Shader编程的需求很高，掌握这项技能可以为开发者带来更多的职业机会。</li><li><strong>理解图形管线</strong>：学习Shader有助于更深入地理解图形渲染管线的工作原理，这对于游戏开发者来说非常重要。</li><li><strong>团队协作</strong>：Shader编程通常需要与美术和设计团队紧密合作，以确保视觉效果与游戏设计相匹配。</li></ol><p>学习Shader编程不仅可以提升个人技术能力，还可以为游戏开发带来更高质量的视觉效果和更好的性能。</p><h1 id="Shader学习大纲"><a href="#Shader学习大纲" class="headerlink" title="Shader学习大纲"></a>Shader学习大纲</h1><ul><li><a href="/Shader/Shader101/" title="渲染管线">渲染管线</a></li><li><a href="/Shader/Shader001/" title="Shader 常用参数">Shader 常用参数</a> 学习中......</li><li><a href="/Shader/Shader002/" title="3D数学">3D数学</a> 学习中......</li></ul><h1 id="卡通渲染学习"><a href="#卡通渲染学习" class="headerlink" title="卡通渲染学习"></a>卡通渲染学习</h1><ul><li><a href="/Shader/ToonShader000/" title="卡通渲染大纲">卡通渲染大纲</a> 学习中......</li></ul><h1 id="水体渲染学习"><a href="#水体渲染学习" class="headerlink" title="水体渲染学习"></a>水体渲染学习</h1><ul><li><a href="/Shader/WaterShader000/" title="水体渲染大纲">水体渲染大纲</a> 学习中......</li></ul><h1 id="Shader学习效果网站"><a href="#Shader学习效果网站" class="headerlink" title="Shader学习效果网站"></a>Shader学习效果网站</h1><p>1.<a href="https://www.shadertoy.com/">ShaderToy</a><br>2.<a href="https://shaderslab.com/">ShadersLab</a></p>]]></content>
      
      
      <categories>
          
          <category> Shader </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shader </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>渲染管线</title>
      <link href="//Shader/Shader101/"/>
      <url>//Shader/Shader101/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>学习Shader就离不开渲染管线，渲染管线是流水线工作的处理形式把3D元素转换到屏幕上2D图像，渲染管线大致分为4个阶段分别是:应用阶段、几何阶段、光栅化阶段、逐片元操作，游戏引擎一般还有一个比较常见的后处理阶段，最后才到输出。</p><h2 id="应用阶段"><a href="#应用阶段" class="headerlink" title="应用阶段"></a>应用阶段</h2><ul><li><strong>准备基本场景数据</strong><ul><li>场景物体数据</li><li>摄像机数据</li><li>光源及阴影数据</li><li>其他全局数据</li></ul></li><li><strong>优化(粗粒度剔除、加速算法)</strong><ul><li>视锥剔除</li><li>遮挡剔除</li><li>层级剔除</li><li>距离剔除</li><li>其他算法</li></ul></li><li><strong>设置渲染状态，准备渲染参数</strong><ul><li>绘制设置(着色器、合批方式)</li><li>绘制顺序(相对摄像机距离、材料RenderQueue、UICanvas等等)</li><li>渲染目标（FrameBuffer、RenderTexture）</li><li>渲染模式(前向渲染、延迟渲染)</li></ul></li><li><strong>调用<a href="#DrawCall">DrawCall</a>，输出<a href="#%E5%9B%BE%E5%85%83">渲染图元</a>到显存</strong><ul><li>顶点数据（位置、颜色、法线、纹理uv坐标）</li><li>其他数据（MVP变化矩阵、纹理贴图等等）</li></ul></li></ul><h2 id="几何阶段"><a href="#几何阶段" class="headerlink" title="几何阶段"></a>几何阶段</h2><ul><li><strong>顶点着色器(Vertex Shading)(可编程)</strong><ul><li>视图转变</li><li>顶点着色</li></ul></li><li><strong>投影</strong><ul><li>正交(<a href="#NDC">NDC</a>中，W等于1)</li><li>透视(<a href="#NDC">NDC</a>中，W代表与摄像机的距离,近小远大)</li></ul></li><li><strong>裁剪</strong><ul><li>视锥体裁剪(CVV)</li><li>正面或背面剔除(可配置)</li></ul></li><li><strong>屏幕映射(Screen Mapping)</strong><ul><li>视口空间坐标会被转换为屏幕坐标，这些坐标直接对应于帧缓冲区中的像素位置。</li><li>屏幕坐标的X和Y值决定了像素在屏幕上的水平和垂直位置，而Z值则用于深度缓冲区中的深度信息。</li></ul></li></ul><h2 id="光栅化阶段"><a href="#光栅化阶段" class="headerlink" title="光栅化阶段"></a>光栅化阶段</h2><ul><li><strong>三角形设置</strong><ul><li>设置直线计算边界信息</li></ul></li><li><strong>三角形遍历</strong><ul><li>遍历填充像素</li></ul></li><li><strong>其他</strong><ul><li><a href="#%E6%8A%97%E9%94%AF%E9%BD%BF">抗锯齿</a>(MSAA)</li></ul></li></ul><h2 id="逐片元操作"><a href="#逐片元操作" class="headerlink" title="逐片元操作"></a>逐片元操作</h2><ul><li><strong>片元着色(可编程)</strong><ul><li>线性插值,求像素颜色</li></ul></li><li><strong>颜色混合</strong> <ul><li>透明度测试</li><li>深度测试</li><li>模板测试</li></ul></li><li><strong>目标缓冲区</strong><ul><li>帧缓冲区FrameBuffer</li><li>渲染贴图RenderTexture</li></ul></li></ul><h2 id="后处理"><a href="#后处理" class="headerlink" title="后处理"></a>后处理</h2><ul><li><strong>Bloom</strong></li><li><strong>HDR</strong></li><li><strong>抗锯齿FXAA</strong></li><li><strong>景深(Depth of View)</strong></li><li><strong>边缘检测</strong></li><li><strong>径向模糊</strong></li></ul><h2 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a>特别说明</h2><p><strong>图元</strong>、<strong>几何图元</strong>、<strong>渲染图元</strong>三个的区别:</p><ul><li><p><strong>图元</strong>（Primitive）: 这是图形渲染中的基本单位，可以是点、线、三角形等。图元是构成更复杂图形和模型的基础⁴。</p></li><li><p><strong>几何图元</strong>（Geometry Primitive）: 这些是由图元组成的，用于描述对象的几何形状。它们是渲染管线中的输入数据，例如顶点数据、纹理坐标、顶点法线和顶点颜色等¹。</p></li><li><p><strong>渲染图元</strong>（Rendering Primitive）: 这些是在图形渲染过程中实际被处理的图元。在OpenGL中，渲染图元包括了渲染所需的几何信息，如顶点数据、线段、多边形等，并且它们对应绘图界面上可见的实体⁵。</p></li></ul><p>简单来说，图元是构建几何图元的基本元素，而渲染图元则是在渲染过程中实际被处理和转换成最终图像的元素。</p><h3 id="图元"><a href="#图元" class="headerlink" title="图元"></a>图元</h3><p><strong>图元（Primitive）</strong>是计算机图形学中的一个术语，它指的是构成计算机生成图像（Computer Graphics, CG）的基本形状或对象。图元是图形渲染过程中的最小单位，可以被视为构建更复杂场景的构建块。以下是一些常见的图元类型：</p><ul><li><strong>点（Point）</strong>：最简单的图元，由一个像素组成。</li><li><strong>线段（Line）</strong>：由两个顶点（Vertex）组成的直线。</li><li><strong>多边形（Polygon）</strong>：由多个顶点组成的封闭形状，如三角形、四边形等。</li><li><strong>曲线（Curve）</strong>：由多个点组成的连续线条，可以是贝塞尔曲线、样条曲线等。</li><li><strong>曲面（Surface）</strong>：由多个多边形组成的复杂形状，可以是平面或曲面。</li><li><strong>纹理（Texture）</strong>：虽然不是图元本身，但纹理是图元的一个重要属性，用于在图元表面添加细节和颜色。</li><li><strong>体素（Voxel）</strong>：在三维空间中的体积元素，类似于二维图像中的像素。</li></ul><h3 id="DrawCall"><a href="#DrawCall" class="headerlink" title="DrawCall"></a>DrawCall</h3><p>在计算机图形学和渲染管线中，Draw Call（绘制调用或绘制命令）是CPU向GPU发出的指令，用于告诉GPU绘制特定的几何图形或图像。一个Draw Call通常包含了一组渲染特定图像所需的全部信息。</p><h3 id="NDC"><a href="#NDC" class="headerlink" title="NDC"></a>NDC</h3><p>在计算机图形学中，NDC（Normalized Device Coordinates，归一化设备坐标）是一种坐标系统，用于在裁剪空间和屏幕空间之间进行转换。NDC坐标系的特点是其坐标值范围在-1到1之间，这使得它们非常适合用于线性变换和透视除法。</p><p>NDC中的<strong>XYZW</strong>四个分量代表：</p><ol><li><p><strong>X</strong>：代表水平方向的坐标，范围从-1到1。在NDC中，-1表示最左边的边界，1表示最右边的边界。</p></li><li><p><strong>Y</strong>：代表垂直方向的坐标，同样范围从-1到1。在NDC中，-1表示最底部的边界，1表示最顶部的边界。请注意，在不同的图形API（如OpenGL和Direct3D）中，Y轴的方向可能相反。</p></li><li><p><strong>Z</strong>：代表深度方向的坐标，也从-1到1。在NDC中，-1通常表示视图的近裁剪平面，而1表示远裁剪平面。</p></li><li><p><strong>W</strong>：这是一个额外的维度，称为齐次坐标（Homogeneous Coordinate）。它通常用于透视除法，以将三维坐标转换为二维坐标。在NDC中，W通常不等于0，因为如果W为0，那么经过透视除法后，X、Y、Z坐标将会变为未定义。</p></li></ol><p>在渲染管线的几何阶段，顶点着色器会输出NDC坐标。然后，这些坐标会经过光栅化阶段，最终转换为屏幕空间坐标，这些屏幕坐标的X和Y分量用于确定像素在帧缓冲区中的位置。</p><p>总结来说，NDC坐标系是渲染管线中一个非常关键的步骤，它允许GPU以一种标准化和高效的方式来处理屏幕映射和透视变换。</p><h3 id="片元"><a href="#片元" class="headerlink" title="片元"></a>片元</h3><p><strong>片元（Pixel）</strong> 是图像处理和计算机图形学中的一个基本概念，指的是构成数字图像的基本单元。每个片元代表图像中的一个点，它具有特定的颜色和亮度值。在数字图像中，所有的颜色和细节都是通过这些片元的组合来表示的。</p><p>以下是片元的一些关键特性：</p><ol><li><p><strong>颜色和亮度</strong>：每个片元都存储有颜色信息，通常用红、绿、蓝（RGB）三个颜色通道的值来表示，这些值决定了片元的颜色和亮度。</p></li><li><p><strong>分辨率</strong>：图像的分辨率由其宽度和高度的片元数量决定。分辨率越高，图像的细节越丰富。</p></li><li><p><strong>像素密度</strong>：像素密度（PPI，Pixels Per Inch）是指每英寸长度内包含的片元数量，它影响图像的清晰度。</p></li><li><p><strong>位深度</strong>：位深度（Bit Depth）是指每个颜色通道可以存储的位数，它决定了颜色的精度。例如，8位颜色深度可以表示256种颜色，而24位颜色深度可以表示超过1600万种颜色。</p></li><li><p><strong>图像格式</strong>：不同的图像格式，如JPEG、PNG、GIF等，决定了片元数据的存储和压缩方式。</p></li></ol><p>在计算机图形学中，片元也用于渲染过程，其中3D模型被转换成2D图像。在这个过程中，3D场景中的每个点在投影到2D平面时，都会转换成一个片元，并根据场景的光照、纹理等属性计算其颜色和亮度值。这个过程称为光栅化（Rasterization）。</p><h3 id="抗锯齿"><a href="#抗锯齿" class="headerlink" title="抗锯齿"></a>抗锯齿</h3><ol><li><strong>SSAA</strong>:渲染到一个分辨率放大n倍的buffer,对放大n倍的buffer下采样</li><li><strong>MSAA</strong>:在光栅化阶段，技术多个覆盖样本</li><li><strong>FXAA&#x2F;TXAA</strong>:后处理技术</li></ol><h3 id="最后的最后-还在学习中会持续修改更新…"><a href="#最后的最后-还在学习中会持续修改更新…" class="headerlink" title="最后的最后,还在学习中会持续修改更新…."></a>最后的最后,还在学习中会持续修改更新….</h3>]]></content>
      
      
      <categories>
          
          <category> Shader </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shader </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shader 常见纹理集定义</title>
      <link href="//Shader/Shader003/"/>
      <url>//Shader/Shader003/</url>
      
        <content type="html"><![CDATA[<h1 id="基本渲染"><a href="#基本渲染" class="headerlink" title="基本渲染"></a>基本渲染</h1><p>普通渲染（通常指的是传统的非基于物理的渲染流程）通常依赖于一组较为简单的纹理集，这些纹理集主要用于模拟光照和表面细节，但不会像PBR那样严格遵循物理规律。以下是普通渲染中常见的一些纹理类型：</p><ol><li><p><strong>漫反射（Diffuse）纹理</strong>：</p><ul><li>作用：存储材质表面的颜色信息，是最基本的纹理。</li><li>描述：漫反射纹理通常包含颜色信息，用于确定物体在普通光照条件下的颜色。</li></ul></li><li><p><strong>高光（Specular）纹理</strong>：</p><ul><li>作用：定义材质表面高光区域的强度和大小。</li><li>描述：高光纹理通常用于控制光照反射的强度和范围，使物体表面在光照下产生亮点。</li></ul></li><li><p><strong>法线（Normal）纹理</strong>：</p><ul><li>作用：模拟表面细节的凹凸感。</li><li>描述：法线纹理提供表面法线信息，用于在渲染时计算光照，从而在不增加几何复杂度的情况下模拟出更加细致的表面凹凸效果。</li></ul></li><li><p><strong>环境光遮蔽（Ambient Occlusion）纹理</strong>：</p><ul><li>作用：模拟光线被周围结构遮挡的效果。</li><li>描述：环境光遮蔽纹理用于在材质表面添加阴影，模拟光线被邻近表面遮挡的情况，增加材质的深度感。</li></ul></li><li><p><strong>反射（Reflection）或镜面（Mirror）纹理</strong>：</p><ul><li>作用：存储反射信息，用于模拟物体表面的反射效果。</li><li>描述：反射纹理通常用于创建光滑表面的反射效果，如镜子或光泽的塑料表面。</li></ul></li><li><p><strong>透明度（Transparency）纹理</strong>：</p><ul><li>作用：定义材质的透明或不透明区域。</li><li>描述：透明度纹理用于创建透明或半透明效果，如窗户、瓶子等。</li></ul></li><li><p><strong>自发光（Emission）纹理</strong>：</p><ul><li>作用：模拟物体自身发光的效果。</li><li>描述：自发光纹理用于创建物体自身发光的效果，常见于特效或者光源物体。</li></ul></li><li><p><strong>光泽度（Glossiness）或光滑度（Smoothness）纹理</strong>：</p><ul><li>作用：控制材质表面对光线的反射方式。</li><li>描述：光泽度纹理通常用于控制物体表面的光泽效果，与高光纹理配合使用，影响高光区域的模糊程度。</li></ul></li><li><p><strong>细节（Detail）纹理</strong>：</p><ul><li>作用：增加材质表面的小细节。</li><li>描述：细节纹理用于在材质表面添加额外的细节层次，如裂缝、磨损等。</li></ul></li><li><p><strong>位移（Displacement）纹理</strong>：</p><ul><li>作用：在几何层面上改变物体的形状。</li><li>描述：位移纹理用于在渲染时改变物体的几何形状，以模拟更复杂的表面结构。</li></ul></li></ol><p>普通渲染流程中的纹理集通常不需要像PBR那样遵循严格的物理规则，因此它们在视觉效果上可能更加灵活，但也可能不如PBR渲染那样真实。在PBR渲染成为主流之前，这些纹理集是游戏和实时渲染中常见的材质定义方式。</p><h1 id="PBR渲染"><a href="#PBR渲染" class="headerlink" title="PBR渲染"></a>PBR渲染</h1><p>PBR（基于物理的渲染）渲染技术在游戏和电影行业中的应用越来越广泛，它通过模拟光线与物体表面的物理交互来实现更加逼真的渲染效果。为了实现PBR渲染，通常需要以下几类纹理集：</p><ol><li><p><strong>基础颜色（Albedo&#x2F;Diffuse）纹理</strong>：存储物体表面的颜色信息，通常是一个RGB纹理图。</p></li><li><p><strong>金属度（Metallic）纹理</strong>：用于区分物体表面是金属还是非金属材质，金属度较高的表面会反射更多的光线，而非金属表面则更多地吸收光线。</p></li><li><p><strong>粗糙度（Roughness）纹理</strong>：控制光线在物体表面的散射程度，粗糙度较高的表面会使得反射光更加分散，而粗糙度较低的表面则会产生较清晰的反射。</p></li><li><p><strong>法线（Normal）纹理</strong>：包含表面每个点的法线方向信息，用于在不增加几何复杂度的情况下模拟出更加细致的表面凹凸效果。</p></li><li><p><strong>高度（Height）纹理</strong>：用于创建物体表面的宏观高度变化，但PBR中较少使用，因为它更多关注微观细节。</p></li><li><p><strong>环境光遮蔽（Ambient Occlusion, AO）纹理</strong>：模拟光线被周围结构遮挡的效果，增加材质的深度感。</p></li><li><p><strong>光泽度（Glossiness）或光滑度（Smoothness）纹理</strong>：与粗糙度纹理相对应，控制材质表面对光线的反射方式。</p></li><li><p><strong>自发光（Emission）纹理</strong>：用于创建物体自身发光的效果，常见于特效或者光源物体。</p></li><li><p><strong>透明度（Transparency）纹理</strong>：定义材质的透明或不透明区域，用于创建透明或半透明效果。</p></li><li><p><strong>反射率（Specularity）纹理</strong>：在某些PBR工作流程中，可能需要一个单独的反射率纹理来存储材质的反射颜色。</p></li></ol><p>这些纹理集共同作用，通过精确模拟光线和材质的物理行为，影响最终的渲染输出，从而带来更逼真的视觉效果。在PBR渲染中，这些纹理的制作和应用需要遵循物理规则，以确保渲染结果的真实性。例如，粗糙度和金属度纹理对于模拟不同材质的光线反射和散射行为至关重要。而基础颜色纹理则定义了材质的基本色彩，是PBR工作流程中不可或缺的一部分。正确地使用这些纹理集，可以显著提升渲染效果的真实感和视觉质量。</p><h1 id="无光照渲染"><a href="#无光照渲染" class="headerlink" title="无光照渲染"></a>无光照渲染</h1><p>Unlit（无光照）渲染是一种不依赖光照计算的渲染方式，它通常用于2D游戏或者那些不需要真实光照效果的场景。在Unlit渲染中，常用的纹理集包括：</p><ol><li><p><strong>基础颜色&#x2F;漫反射（Base Map&#x2F;Diffuse Map）</strong>：这是最主要的纹理，用于定义物体表面的颜色和图案。在Unlit渲染中，这个纹理决定了物体的视觉外观，因为它不受光照影响。</p></li><li><p><strong>透明度（Transparency）</strong>：如果材质需要透明效果，可以使用透明度纹理来定义哪些区域是透明的。透明度纹理通常使用Alpha通道来实现透明效果。</p></li><li><p><strong>自发光（Emission）</strong>：即使在Unlit渲染中，有时也需要某些物体部分能够发光。自发光纹理可以用来定义这些发光区域和发光强度。</p></li><li><p><strong>法线（Normal）</strong>：虽然Unlit渲染不考虑光照，但法线纹理有时用于创建扁平的、卡通风格的渲染效果，或者在某些特效中模拟凹凸感。</p></li><li><p><strong>细节（Detail）</strong>：细节纹理可以用来增加材质的复杂度，比如模拟表面的小裂缝或者磨损效果。</p></li></ol><p>在Unity中，Unlit渲染可以通过选择相应的Shader来实现。例如，在Universal Render Pipeline (URP) 中，你可以选择“Universal Render Pipeline &gt; Unlit”作为Shader。在High Definition Render Pipeline (HDRP) 中，你可以选择“HDRP &gt; Unlit”。这些Shader通常包含一些基本的属性，如颜色、纹理、透明度等，以及一些高级选项，如GPU实例化和渲染通道设置。</p><p>Unlit Shader的Inspector界面通常包含以下元素：</p><ul><li><strong>Surface Options</strong>：控制材质在屏幕上的渲染方式，如表面类型（Opaque或Transparent）、混合模式（如Alpha、Premultiply、Additive、Multiply）等。</li><li><strong>Surface Inputs</strong>：描述表面本身，如基础颜色纹理、纹理平铺（Tiling）和偏移（Offset）。</li><li><strong>Advanced</strong>：高级设置，影响渲染的底层计算，如GPU实例化。</li></ul><p>在创建Unlit材质时，你可以根据需要调整这些属性来实现所需的视觉效果。例如，你可以设置基础颜色纹理来定义材质的颜色，使用透明度纹理来创建透明效果，或者调整纹理平铺和偏移来控制纹理在物体上的布局。这些纹理和设置共同工作，使得Unlit渲染能够提供简单而有效的视觉效果。 </p><h1 id="卡通渲染"><a href="#卡通渲染" class="headerlink" title="卡通渲染"></a>卡通渲染</h1><p>卡通渲染（也称为卡通着色或漫画渲染）是一种非真实感渲染技术，它旨在模仿传统卡通或漫画的视觉风格。这种渲染风格通常不追求物理上的准确性，而是追求视觉上的夸张和风格化效果。卡通渲染可能需要以下类型的纹理集：</p><ol><li><p><strong>漫反射（Diffuse）纹理</strong>：</p><ul><li>作用：存储材质的基本颜色信息。</li><li>描述：漫反射纹理在卡通渲染中用于定义物体的基础色彩。</li></ul></li><li><p><strong>轮廓线（Outline）纹理</strong>：</p><ul><li>作用：创建物体的轮廓线，增强视觉的分离感。</li><li>描述：轮廓线纹理或效果用于在物体边缘添加明显的线框，这是卡通渲染中的一个重要特征。</li></ul></li><li><p><strong>高光（Specular）纹理</strong>：</p><ul><li>作用：定义材质表面的高光区域。</li><li>描述：在某些卡通风格中，可能会使用高光纹理来模拟光线集中照射的区域，但通常比真实感渲染更为夸张和风格化。</li></ul></li><li><p><strong>法线（Normal）纹理</strong>：</p><ul><li>作用：模拟表面的凹凸感。</li><li>描述：法线纹理可以用于在不增加几何细节的情况下，通过光照变化来模拟表面的凹凸效果。</li></ul></li><li><p><strong>自发光（Emission）纹理</strong>：</p><ul><li>作用：模拟物体自身发光的效果。</li><li>描述：自发光纹理在卡通渲染中可以用来创建特效，如发光的眼睛或魔法效果。</li></ul></li><li><p><strong>纹理蒙版（Texture Masks）</strong>：</p><ul><li>作用：用于控制不同纹理效果的混合和应用区域。</li><li>描述：纹理蒙版可以用来定义哪些区域应该显示特定的纹理效果，例如，控制哪里应该有高光或阴影。</li></ul></li><li><p><strong>颜色渐变（Gradient）纹理</strong>：</p><ul><li>作用：创建颜色的渐变效果。</li><li>描述：颜色渐变纹理可以用来模拟光照变化，或者在卡通渲染中创建特殊的视觉效果。</li></ul></li><li><p><strong>光泽度（Glossiness）纹理</strong>：</p><ul><li>作用：控制材质表面反射的模糊程度。</li><li>描述：在一些卡通渲染风格中，可能会使用光泽度纹理来模拟不同程度的光泽效果。</li></ul></li><li><p><strong>纹理混合（Texture Blending）</strong>：</p><ul><li>作用：将不同的纹理效果混合在一起。</li><li>描述：通过混合不同的纹理，可以创造出独特的视觉效果，如将不同的颜色或图案应用到材质的不同区域。</li></ul></li><li><p><strong>细节（Detail）纹理</strong>：</p><ul><li>作用：增加材质表面的小细节。</li><li>描述：细节纹理可以用来增强材质的视觉效果，使其更加丰富和有趣。</li></ul></li></ol><p>卡通渲染的关键在于风格化和夸张的视觉效果，因此纹理集的使用和处理方式可能会根据所需的艺术风格和视觉效果有很大差异。在实现卡通渲染时，开发者和美术人员会根据项目的需求和风格来选择和设计合适的纹理集。</p><h1 id="其他贴图"><a href="#其他贴图" class="headerlink" title="其他贴图"></a>其他贴图</h1><p>在游戏渲染中，除了前面提到的纹理集，还有一些其他的纹理类型可以用于创造丰富的视觉效果：</p><ol><li><p><strong>纹理图集（Texture Atlas）</strong>：这是一种包含多个较小贴图的图像，通常它们打包在一起以减少整体尺寸，有效减少GPU纹理内存的开销，并提供更多的灵活性。纹理图集可以通过工具如TexturePacker或Unity的Sprite Packer创建 。</p></li><li><p><strong>自定义渲染纹理（Custom Render Texture）</strong>：这是一种特殊类型的纹理，可以通过着色器更新纹理，用于创建复杂的模拟，如焦散、雨水效果的波纹模拟和液体喷溅 。</p></li><li><p><strong>环境贴图（Cubemap）</strong>：用于存储环境的全景图像，常用于反射和折射效果，模拟物体表面反射周围环境的场景。</p></li><li><p><strong>光晕贴图（Bloom&#x2F;Glare Texture）</strong>：用于创建亮度过高时产生的光晕效果，增强视觉冲击力。</p></li><li><p><strong>特效贴图（Effect Maps）</strong>：用于实现特定的视觉效果，如魔法效果、爆炸、火光等。</p></li><li><p><strong>细节增强贴图（Detail Maps）</strong>：用于在不增加模型多边形数量的情况下，通过纹理细节增强模型的表面细节。</p></li><li><p><strong>遮挡贴图（Occlusion Maps）</strong>：用于模拟光线被物体表面结构遮挡的效果，增加材质的深度感。</p></li><li><p><strong>光泽度贴图（Glossiness Maps）</strong>：用于控制材质表面对光线的反射模糊程度，与粗糙度纹理相对应。</p></li><li><p><strong>透明度贴图（Translucency Maps）</strong>：用于创建半透明效果，如叶子、皮肤等。</p></li><li><p><strong>水波纹贴图（Water Caustics）</strong>：用于模拟水下的光线折射和波纹效果。</p></li><li><p><strong>粒子纹理（Particle Textures）</strong>：用于定义粒子系统中粒子的外观，如烟雾、火焰、魔法粒子等。</p></li><li><p><strong>纹理蒙版（Texture Masks）</strong>：用于控制不同纹理效果的混合和应用区域，比如控制哪些区域显示高光或阴影。</p></li></ol><p>这些纹理集可以单独使用或组合使用，以实现所需的视觉效果。在游戏渲染中，材质的视觉表现主要依赖于这些纹理集和着色器的属性设置。</p>]]></content>
      
      
      <categories>
          
          <category> Shader </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shader </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cocos Creator Shader完整学习指南</title>
      <link href="//CocosShader/cocos-creator-shader-complete-learning-guide/"/>
      <url>//CocosShader/cocos-creator-shader-complete-learning-guide/</url>
      
        <content type="html"><![CDATA[<h1 id="Cocos-Creator-Shader完整学习指南"><a href="#Cocos-Creator-Shader完整学习指南" class="headerlink" title="Cocos Creator Shader完整学习指南"></a>Cocos Creator Shader完整学习指南</h1><p>欢迎来到Cocos Creator Shader完整学习系列！本系列教程将带你从零开始，系统性地学习Cocos Creator中的着色器编程，基于<a href="https://docs.cocos.com/creator/3.8/manual/zh/shader/">Cocos Creator官方文档</a>进行详细讲解。</p><span id="more"></span><h2 id="🎯-学习目标"><a href="#🎯-学习目标" class="headerlink" title="🎯 学习目标"></a>🎯 学习目标</h2><p>通过本系列教程，你将能够：</p><ul><li>理解Cocos Creator中着色器的工作原理</li><li>掌握Surface Shader和Legacy Shader的编写</li><li>学会创建各种视觉效果（PBR材质、卡通渲染、特效等）</li><li>理解渲染管线和光照模型</li><li>具备独立开发复杂着色器的能力</li></ul><h2 id="📚-学习路径"><a href="#📚-学习路径" class="headerlink" title="📚 学习路径"></a>📚 学习路径</h2><h3 id="🚀-入门篇（第1-3章）"><a href="#🚀-入门篇（第1-3章）" class="headerlink" title="🚀 入门篇（第1-3章）"></a>🚀 入门篇（第1-3章）</h3><h4 id="第1章：基础概念与环境搭建"><a href="#第1章：基础概念与环境搭建" class="headerlink" title="第1章：基础概念与环境搭建"></a>第1章：基础概念与环境搭建</h4><ul><li><a href="/CocosShader/cocos-shader-basics-concepts/" title="第1章：Cocos Shader基础概念">第1章：Cocos Shader基础概念</a></li><li><a href="/CocosShader/cocos-shader-development-environment/" title="第2章：Cocos Shader开发环境搭建">第2章：Cocos Shader开发环境搭建</a></li><li><a href="/CocosShader/cocos-shader-syntax-introduction/" title="第3章：Cocos Shader语法详解">第3章：Cocos Shader语法详解</a></li></ul><h4 id="第2章：Cocos-Shader语法基础"><a href="#第2章：Cocos-Shader语法基础" class="headerlink" title="第2章：Cocos Shader语法基础"></a>第2章：Cocos Shader语法基础</h4><ul><li><a href="/CocosShader/cocos-shader-syntax-introduction/" title="第3章：Cocos Shader语法详解">第3章：Cocos Shader语法详解</a></li><li>YAML配置详解 (即将推出)</li><li>GLSL基础语法 (即将推出)</li></ul><h4 id="第3章：创建与使用着色器"><a href="#第3章：创建与使用着色器" class="headerlink" title="第3章：创建与使用着色器"></a>第3章：创建与使用着色器</h4><ul><li>创建和使用着色器 (即将推出)</li><li>着色器材质系统 (即将推出)</li><li>着色器调试工具 (即将推出)</li></ul><h3 id="🎨-进阶篇（第4-7章）"><a href="#🎨-进阶篇（第4-7章）" class="headerlink" title="🎨 进阶篇（第4-7章）"></a>🎨 进阶篇（第4-7章）</h3><h4 id="第4章：内置着色器详解"><a href="#第4章：内置着色器详解" class="headerlink" title="第4章：内置着色器详解"></a>第4章：内置着色器详解</h4><ul><li>内置着色器概览 (即将推出)</li><li>无光照着色器教程 (即将推出)</li><li><a href="/CocosShader/pbr-shader-fundamentals/" title="第4章：PBR着色器基础教程">第4章：PBR着色器基础教程</a></li><li>卡通着色器实现 (即将推出)</li></ul><h4 id="第5章：Surface-Shader深入"><a href="#第5章：Surface-Shader深入" class="headerlink" title="第5章：Surface Shader深入"></a>第5章：Surface Shader深入</h4><ul><li><a href="/CocosShader/surface-shader-introduction/" title="第5章：Surface Shader深入介绍">第5章：Surface Shader深入介绍</a></li><li>Surface Shader结构详解 (即将推出)</li><li>执行流程详解 (即将推出)</li><li>Include机制详解 (即将推出)</li></ul><h4 id="第6章：光照模型与材质"><a href="#第6章：光照模型与材质" class="headerlink" title="第6章：光照模型与材质"></a>第6章：光照模型与材质</h4><ul><li>光照模型详解 (即将推出)</li><li>PBR光照模型 (即将推出)</li><li>自定义光照函数 (即将推出)</li><li>材质数据结构 (即将推出)</li></ul><h4 id="第7章：宏定义与函数重映射"><a href="#第7章：宏定义与函数重映射" class="headerlink" title="第7章：宏定义与函数重映射"></a>第7章：宏定义与函数重映射</h4><ul><li>宏定义指南 (即将推出)</li><li>函数重映射技术 (即将推出)</li><li>可替换内置函数 (即将推出)</li></ul><h3 id="🔧-实战篇（第8-11章）"><a href="#🔧-实战篇（第8-11章）" class="headerlink" title="🔧 实战篇（第8-11章）"></a>🔧 实战篇（第8-11章）</h3><h4 id="第8章：自定义Surface-Shader"><a href="#第8章：自定义Surface-Shader" class="headerlink" title="第8章：自定义Surface Shader"></a>第8章：自定义Surface Shader</h4><ul><li>自定义Surface Shader基础 (即将推出)</li><li>边缘光Surface Shader (即将推出)</li><li>溶解特效Surface Shader (即将推出)</li><li>水面Surface Shader (即将推出)</li></ul><h4 id="第9章：2D着色器特效"><a href="#第9章：2D着色器特效" class="headerlink" title="第9章：2D着色器特效"></a>第9章：2D着色器特效</h4><ul><li><a href="/CocosShader/2d-gradient-sprite-shader/" title="第9章：2D渐变精灵着色器实战">第9章：2D渐变精灵着色器实战</a></li><li>2D波纹扭曲着色器 (即将推出)</li><li>2D颜色替换着色器 (即将推出)</li><li>2D描边着色器 (即将推出)</li></ul><h4 id="第10章：3D高级特效"><a href="#第10章：3D高级特效" class="headerlink" title="第10章：3D高级特效"></a>第10章：3D高级特效</h4><ul><li>3D高级边缘光 (即将推出)</li><li>3D全息投影着色器 (即将推出)</li><li>3D力场着色器 (即将推出)</li><li>3D顶点动画 (即将推出)</li></ul><h4 id="第11章：渲染管线与优化"><a href="#第11章：渲染管线与优化" class="headerlink" title="第11章：渲染管线与优化"></a>第11章：渲染管线与优化</h4><ul><li>渲染管线概览 (即将推出)</li><li>前向vs延迟渲染 (即将推出)</li><li>着色器优化技术 (即将推出)</li><li>移动端着色器优化 (即将推出)</li></ul><h3 id="🏆-高级篇（第12-15章）"><a href="#🏆-高级篇（第12-15章）" class="headerlink" title="🏆 高级篇（第12-15章）"></a>🏆 高级篇（第12-15章）</h3><h4 id="第12章：Legacy-Shader详解"><a href="#第12章：Legacy-Shader详解" class="headerlink" title="第12章：Legacy Shader详解"></a>第12章：Legacy Shader详解</h4><ul><li>Legacy Shader介绍 (即将推出)</li><li>Legacy Shader函数 (即将推出)</li><li>Legacy vs Surface Shader (即将推出)</li></ul><h4 id="第13章：高级渲染技术"><a href="#第13章：高级渲染技术" class="headerlink" title="第13章：高级渲染技术"></a>第13章：高级渲染技术</h4><ul><li>自定义几何实例化 (即将推出)</li><li>UBO内存布局 (即将推出)</li><li>多pass渲染 (即将推出)</li><li>渲染纹理技术 (即将推出)</li></ul><h4 id="第14章：跨平台兼容性"><a href="#第14章：跨平台兼容性" class="headerlink" title="第14章：跨平台兼容性"></a>第14章：跨平台兼容性</h4><ul><li>WebGL兼容性 (即将推出)</li><li>移动平台着色器 (即将推出)</li><li>性能分析 (即将推出)</li></ul><h4 id="第15章：工具与工作流"><a href="#第15章：工具与工作流" class="headerlink" title="第15章：工具与工作流"></a>第15章：工具与工作流</h4><ul><li>VSCode着色器扩展 (即将推出)</li><li>着色器开发工作流 (即将推出)</li><li>着色器资源管理 (即将推出)</li></ul><h2 id="🛠️-开发环境要求"><a href="#🛠️-开发环境要求" class="headerlink" title="🛠️ 开发环境要求"></a>🛠️ 开发环境要求</h2><h3 id="软件要求"><a href="#软件要求" class="headerlink" title="软件要求"></a>软件要求</h3><ul><li><strong>Cocos Creator</strong>: 3.8.x 版本</li><li><strong>代码编辑器</strong>: VSCode（推荐安装Cocos Shader扩展）</li><li><strong>图像工具</strong>: Photoshop&#x2F;GIMP（用于纹理制作）</li></ul><h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><ul><li><strong>必需</strong>: JavaScript&#x2F;TypeScript基础</li><li><strong>推荐</strong>: 线性代数基础、计算机图形学概念</li><li><strong>加分</strong>: OpenGL&#x2F;WebGL经验</li></ul><h2 id="📖-学习建议"><a href="#📖-学习建议" class="headerlink" title="📖 学习建议"></a>📖 学习建议</h2><h3 id="学习顺序"><a href="#学习顺序" class="headerlink" title="学习顺序"></a>学习顺序</h3><ol><li><strong>按章节顺序学习</strong> - 每章都为后续内容奠定基础</li><li><strong>理论结合实践</strong> - 每个概念都要动手实现</li><li><strong>多做实验</strong> - 修改参数观察效果变化</li><li><strong>参考官方文档</strong> - 深入了解API细节</li></ol><h3 id="实践项目"><a href="#实践项目" class="headerlink" title="实践项目"></a>实践项目</h3><ul><li><strong>入门</strong>: 简单的颜色变化效果</li><li><strong>进阶</strong>: 完整的材质系统</li><li><strong>高级</strong>: 复杂的视觉特效</li></ul><h3 id="学习时间规划"><a href="#学习时间规划" class="headerlink" title="学习时间规划"></a>学习时间规划</h3><ul><li><strong>入门篇</strong>: 2-3周（每天1-2小时）</li><li><strong>进阶篇</strong>: 3-4周（需要更多实践时间）</li><li><strong>实战篇</strong>: 4-5周（大量编程实践）</li><li><strong>高级篇</strong>: 2-3周（深度理解）</li></ul><h2 id="🔗-相关资源"><a href="#🔗-相关资源" class="headerlink" title="🔗 相关资源"></a>🔗 相关资源</h2><h3 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h3><ul><li><a href="https://docs.cocos.com/creator/3.8/manual/zh/shader/">Cocos Creator Shader文档</a></li><li><a href="https://docs.cocos.com/creator/3.8/api/">Cocos Creator API参考</a></li></ul><h3 id="社区资源"><a href="#社区资源" class="headerlink" title="社区资源"></a>社区资源</h3><ul><li><a href="https://forum.cocos.org/">Cocos Creator论坛</a></li><li><a href="https://github.com/cocos/cocos-example-projects">GitHub示例项目</a></li></ul><h3 id="相关教程"><a href="#相关教程" class="headerlink" title="相关教程"></a>相关教程</h3><ul><li><a href="/Shader/Shader000/" title="Shader 学习大纲">Shader 学习大纲</a></li><li><a href="/ShaderGraph/ShaderGraph000/" title="ShaderGraph 学习大纲">ShaderGraph 学习大纲</a></li></ul><h2 id="💡-学习tips"><a href="#💡-学习tips" class="headerlink" title="💡 学习tips"></a>💡 学习tips</h2><ol><li><strong>从简单开始</strong>: 不要急于实现复杂效果</li><li><strong>理解原理</strong>: 知道为什么这样写，而不只是复制代码</li><li><strong>多实验</strong>: 修改参数，观察结果</li><li><strong>记录笔记</strong>: 记录重要概念和调试技巧</li><li><strong>分享交流</strong>: 与其他开发者讨论问题和心得</li></ol><h2 id="🎊-开始学习"><a href="#🎊-开始学习" class="headerlink" title="🎊 开始学习"></a>🎊 开始学习</h2><p>准备好了吗？让我们从第一章开始：</p><p>👉 <strong><a href="!--swig%EF%BF%BC9--">第1章：Cocos Shader基础概念</a></strong></p><p>愿你在Cocos Creator Shader的学习路上收获满满！</p><hr><blockquote><p><strong>更新日志</strong></p><ul><li>2024年12月: 创建完整学习指南</li><li>持续更新中…</li></ul></blockquote><blockquote><p><strong>联系方式</strong><br>如果你在学习过程中遇到问题，欢迎在评论区留言或通过其他方式联系我们。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> CocosShader </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CocosShader </tag>
            
            <tag> Learning Guide </tag>
            
            <tag> Tutorial Series </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第1章：Cocos Shader基础概念</title>
      <link href="//CocosShader/cocos-shader-basics-concepts/"/>
      <url>//CocosShader/cocos-shader-basics-concepts/</url>
      
        <content type="html"><![CDATA[<h1 id="第1章：Cocos-Shader基础概念"><a href="#第1章：Cocos-Shader基础概念" class="headerlink" title="第1章：Cocos Shader基础概念"></a>第1章：Cocos Shader基础概念</h1><p>在现代游戏开发中，着色器（Shader）是实现各种视觉效果的核心技术。本章将介绍Cocos Creator中着色器的基本概念，为后续深入学习打下坚实基础。</p><span id="more"></span><h2 id="🎯-学习目标"><a href="#🎯-学习目标" class="headerlink" title="🎯 学习目标"></a>🎯 学习目标</h2><p>通过本章学习，你将了解：</p><ul><li>着色器的基本概念和工作原理</li><li>Cocos Creator中着色器的特点</li><li>渲染管线的基础知识</li><li>顶点着色器和片元着色器的作用</li></ul><h2 id="💡-什么是着色器（Shader）？"><a href="#💡-什么是着色器（Shader）？" class="headerlink" title="💡 什么是着色器（Shader）？"></a>💡 什么是着色器（Shader）？</h2><h3 id="着色器的定义"><a href="#着色器的定义" class="headerlink" title="着色器的定义"></a>着色器的定义</h3><p>着色器（Shader）是运行在GPU上的小程序，用于控制图形渲染管线中顶点和像素的处理过程。在现代图形编程中，着色器是实现各种视觉效果的关键技术。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简单的顶点着色器示例</span></span><br><span class="line"><span class="keyword">attribute</span> <span class="type">vec3</span> a_position;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> u_mvpMatrix;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    <span class="built_in">gl_Position</span> = u_mvpMatrix * <span class="type">vec4</span>(a_position, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="着色器的类型"><a href="#着色器的类型" class="headerlink" title="着色器的类型"></a>着色器的类型</h3><p>在3D图形渲染中，主要有两种着色器：</p><ol><li><p><strong>顶点着色器（Vertex Shader）</strong></p><ul><li>处理每个顶点的数据</li><li>负责顶点变换、光照计算等</li><li>输出最终的顶点位置</li></ul></li><li><p><strong>片元着色器（Fragment Shader）</strong></p><ul><li>处理每个像素的数据</li><li>负责纹理采样、颜色计算等</li><li>输出最终的像素颜色</li></ul></li></ol><h2 id="🌟-Cocos-Creator中的着色器"><a href="#🌟-Cocos-Creator中的着色器" class="headerlink" title="🌟 Cocos Creator中的着色器"></a>🌟 Cocos Creator中的着色器</h2><h3 id="Cocos-Shader的特点"><a href="#Cocos-Shader的特点" class="headerlink" title="Cocos Shader的特点"></a>Cocos Shader的特点</h3><p><a href="https://docs.cocos.com/creator/3.8/manual/zh/shader/">Cocos Creator</a>基于GLSL封装了一套着色器系统——Cocos Shader，具有以下特点：</p><ol><li><p><strong>工业化流程友好</strong></p><ul><li>统一的语法规范</li><li>完善的材质系统</li><li>便于团队协作</li></ul></li><li><p><strong>跨平台兼容</strong></p><ul><li>支持WebGL 1.0&#x2F;2.0</li><li>适配移动端性能</li><li>自动处理平台差异</li></ul></li><li><p><strong>易于使用</strong></p><ul><li>简化的语法结构</li><li>丰富的内置函数</li><li>完善的调试工具</li></ul></li></ol><h3 id="Cocos-Shader的结构"><a href="#Cocos-Shader的结构" class="headerlink" title="Cocos Shader的结构"></a>Cocos Shader的结构</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Cocos Shader基本结构</span></span><br><span class="line"><span class="attr">CCEffect:</span></span><br><span class="line">  <span class="attr">techniques:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">example</span></span><br><span class="line">      <span class="attr">passes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">vert:</span> <span class="string">example-vs</span></span><br><span class="line">          <span class="attr">frag:</span> <span class="string">example-fs</span></span><br><span class="line">          <span class="attr">properties:</span></span><br><span class="line">            <span class="attr">mainTexture:</span> &#123; <span class="attr">value:</span> <span class="string">white</span> &#125;</span><br></pre></td></tr></table></figure><h2 id="🔄-渲染管线基础"><a href="#🔄-渲染管线基础" class="headerlink" title="🔄 渲染管线基础"></a>🔄 渲染管线基础</h2><h3 id="图形渲染管线概述"><a href="#图形渲染管线概述" class="headerlink" title="图形渲染管线概述"></a>图形渲染管线概述</h3><p>渲染管线是将3D场景转换为2D图像的一系列步骤：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">    A[顶点数据] --&gt; B[顶点着色器]</span><br><span class="line">    B --&gt; C[图元装配]</span><br><span class="line">    C --&gt; D[光栅化]</span><br><span class="line">    D --&gt; E[片元着色器]</span><br><span class="line">    E --&gt; F[最终像素]</span><br></pre></td></tr></table></figure><h3 id="关键阶段解析"><a href="#关键阶段解析" class="headerlink" title="关键阶段解析"></a>关键阶段解析</h3><ol><li><p><strong>顶点处理阶段</strong></p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 顶点变换</span></span><br><span class="line"><span class="type">vec4</span> worldPos = u_model * <span class="type">vec4</span>(a_position, <span class="number">1.0</span>);</span><br><span class="line"><span class="type">vec4</span> viewPos = u_view * worldPos;</span><br><span class="line"><span class="built_in">gl_Position</span> = u_proj * viewPos;</span><br></pre></td></tr></table></figure></li><li><p><strong>光栅化阶段</strong></p><ul><li>将几何图元转换为像素</li><li>插值顶点属性</li></ul></li><li><p><strong>片元处理阶段</strong></p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 纹理采样和颜色计算</span></span><br><span class="line"><span class="type">vec4</span> texColor = <span class="built_in">texture</span>(u_mainTexture, v_uv);</span><br><span class="line"><span class="built_in">gl_FragColor</span> = texColor * u_color;</span><br></pre></td></tr></table></figure></li></ol><h2 id="🎨-着色器的应用场景"><a href="#🎨-着色器的应用场景" class="headerlink" title="🎨 着色器的应用场景"></a>🎨 着色器的应用场景</h2><h3 id="常见视觉效果"><a href="#常见视觉效果" class="headerlink" title="常见视觉效果"></a>常见视觉效果</h3><ol><li><p><strong>基础材质</strong></p><ul><li>无光照材质（Unlit）</li><li>PBR材质（Physically Based Rendering）</li><li>透明材质</li></ul></li><li><p><strong>特殊效果</strong></p><ul><li>卡通渲染（Toon Shading）</li><li>边缘光效果（Rim Lighting）</li><li>溶解效果（Dissolve）</li></ul></li><li><p><strong>后处理效果</strong></p><ul><li>模糊效果</li><li>色调映射</li><li>屏幕空间反射</li></ul></li></ol><h3 id="实际应用示例"><a href="#实际应用示例" class="headerlink" title="实际应用示例"></a>实际应用示例</h3><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简单的卡通着色器</span></span><br><span class="line"><span class="type">float</span> NdotL = <span class="built_in">max</span>(<span class="number">0.0</span>, <span class="built_in">dot</span>(normal, lightDir));</span><br><span class="line"><span class="type">float</span> toonLevel = <span class="built_in">floor</span>(NdotL * <span class="number">3.0</span>) / <span class="number">3.0</span>;</span><br><span class="line"><span class="type">vec3</span> toonColor = baseColor * toonLevel;</span><br></pre></td></tr></table></figure><h2 id="🛠️-开发环境准备"><a href="#🛠️-开发环境准备" class="headerlink" title="🛠️ 开发环境准备"></a>🛠️ 开发环境准备</h2><h3 id="必需软件"><a href="#必需软件" class="headerlink" title="必需软件"></a>必需软件</h3><ol><li><p><strong>Cocos Creator 3.8.x</strong></p><ul><li>最新稳定版本</li><li>内置着色器编辑器</li></ul></li><li><p><strong>VSCode + Cocos Shader扩展</strong></p><ul><li>语法高亮</li><li>代码补全</li><li>错误检查</li></ul></li></ol><h3 id="项目设置"><a href="#项目设置" class="headerlink" title="项目设置"></a>项目设置</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TypeScript中使用材质</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Material</span>, <span class="title class_">MeshRenderer</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;cc&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> material = <span class="keyword">new</span> <span class="title class_">Material</span>();</span><br><span class="line">material.<span class="title function_">initialize</span>(&#123;</span><br><span class="line">    <span class="attr">effectName</span>: <span class="string">&#x27;custom-shader&#x27;</span>,</span><br><span class="line">    <span class="attr">states</span>: &#123;</span><br><span class="line">        <span class="attr">cullMode</span>: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> meshRenderer = <span class="variable language_">this</span>.<span class="title function_">getComponent</span>(<span class="title class_">MeshRenderer</span>);</span><br><span class="line">meshRenderer.<span class="property">material</span> = material;</span><br></pre></td></tr></table></figure><h2 id="📊-性能考虑"><a href="#📊-性能考虑" class="headerlink" title="📊 性能考虑"></a>📊 性能考虑</h2><h3 id="移动端优化"><a href="#移动端优化" class="headerlink" title="移动端优化"></a>移动端优化</h3><ol><li><p><strong>减少计算复杂度</strong></p><ul><li>避免复杂的数学运算</li><li>使用查找表（LUT）</li><li>预计算常量</li></ul></li><li><p><strong>纹理优化</strong></p><ul><li>合理的纹理大小</li><li>压缩纹理格式</li><li>减少纹理采样次数</li></ul></li></ol><h3 id="调试技巧"><a href="#调试技巧" class="headerlink" title="调试技巧"></a>调试技巧</h3><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调试着色器的常用技巧</span></span><br><span class="line"><span class="comment">// 1. 输出中间值作为颜色</span></span><br><span class="line"><span class="built_in">gl_FragColor</span> = <span class="type">vec4</span>(normal * <span class="number">0.5</span> + <span class="number">0.5</span>, <span class="number">1.0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 分阶段调试</span></span><br><span class="line"><span class="meta">#ifdef DEBUG_NORMALS</span></span><br><span class="line">    <span class="built_in">gl_FragColor</span> = <span class="type">vec4</span>(normal * <span class="number">0.5</span> + <span class="number">0.5</span>, <span class="number">1.0</span>);</span><br><span class="line"><span class="meta">#endif</span></span><br></pre></td></tr></table></figure><h2 id="🔍-深入思考"><a href="#🔍-深入思考" class="headerlink" title="🔍 深入思考"></a>🔍 深入思考</h2><h3 id="着色器-vs-传统渲染"><a href="#着色器-vs-传统渲染" class="headerlink" title="着色器 vs 传统渲染"></a>着色器 vs 传统渲染</h3><table><thead><tr><th>传统渲染</th><th>着色器渲染</th></tr></thead><tbody><tr><td>固定管线</td><td>可编程管线</td></tr><tr><td>有限效果</td><td>无限创意</td></tr><tr><td>CPU处理</td><td>GPU并行处理</td></tr></tbody></table><h3 id="学习路径建议"><a href="#学习路径建议" class="headerlink" title="学习路径建议"></a>学习路径建议</h3><ol><li><strong>理论基础</strong>：线性代数、计算机图形学</li><li><strong>语言学习</strong>：GLSL语法和函数</li><li><strong>实践项目</strong>：从简单效果开始</li><li><strong>高级技巧</strong>：性能优化和调试</li></ol><h2 id="📚-本章总结"><a href="#📚-本章总结" class="headerlink" title="📚 本章总结"></a>📚 本章总结</h2><p>通过本章学习，我们了解了：</p><ul><li>✅ 着色器的基本概念和分类</li><li>✅ Cocos Creator中着色器的特点</li><li>✅ 图形渲染管线的基本流程</li><li>✅ 着色器的常见应用场景</li><li>✅ 开发环境的搭建要求</li></ul><h2 id="🚀-下一步"><a href="#🚀-下一步" class="headerlink" title="🚀 下一步"></a>🚀 下一步</h2><p>现在你已经掌握了Cocos Shader的基础概念，接下来我们将学习如何搭建开发环境：</p><p>👉 <strong><a href="!--swig%EF%BF%BC8--">第2章：Cocos Shader开发环境搭建</a></strong></p><h2 id="💡-练习思考"><a href="#💡-练习思考" class="headerlink" title="💡 练习思考"></a>💡 练习思考</h2><ol><li>着色器相比传统渲染方法有哪些优势？</li><li>顶点着色器和片元着色器分别负责什么工作？</li><li>在移动端开发中需要注意哪些性能问题？</li></ol><hr><blockquote><p><strong>参考资料</strong></p><ul><li><a href="https://docs.cocos.com/creator/3.8/manual/zh/shader/">Cocos Creator Shader官方文档</a></li><li><a href="https://www.khronos.org/opengl/wiki/OpenGL_Shading_Language">OpenGL Shading Language规范</a></li></ul></blockquote><blockquote><p><strong>系列导航</strong></p><ul><li><a href="!--swig%EF%BF%BC9--">返回学习指南</a></li><li><a href="!--swig%EF%BF%BC10--">下一章：开发环境搭建</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> CocosShader </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CocosShader </tag>
            
            <tag> Basics </tag>
            
            <tag> Fundamentals </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cocos Creator Shader教程系列总结</title>
      <link href="//CocosShader/cocos-shader-series-summary/"/>
      <url>//CocosShader/cocos-shader-series-summary/</url>
      
        <content type="html"><![CDATA[<h1 id="Cocos-Creator-Shader教程系列-项目总结"><a href="#Cocos-Creator-Shader教程系列-项目总结" class="headerlink" title="Cocos Creator Shader教程系列 - 项目总结"></a>Cocos Creator Shader教程系列 - 项目总结</h1><h2 id="🎊-系列完成状态"><a href="#🎊-系列完成状态" class="headerlink" title="🎊 系列完成状态"></a>🎊 系列完成状态</h2><p>基于<a href="https://docs.cocos.com/creator/3.8/manual/zh/shader/">Cocos Creator官方Shader文档</a>，我们已经成功创建了完整的Cocos Shader学习系列！</p><h2 id="📚-已创建的文章"><a href="#📚-已创建的文章" class="headerlink" title="📚 已创建的文章"></a>📚 已创建的文章</h2><h3 id="核心文章（7篇）"><a href="#核心文章（7篇）" class="headerlink" title="核心文章（7篇）"></a>核心文章（7篇）</h3><ol><li><p><strong>学习指南（置顶）</strong></p><ul><li><code>cocos-creator-shader-complete-learning-guide.md</code></li><li>完整的学习路径规划（15章内容）</li><li>包含60+篇文章的详细分类</li></ul></li><li><p><strong>第1章：基础概念</strong></p><ul><li><a href="/CocosShader/cocos-shader-basics-concepts/" title="第1章：Cocos Shader基础概念">第1章：Cocos Shader基础概念</a></li><li>详细的着色器概念介绍</li><li>渲染管线基础知识</li></ul></li><li><p><strong>第2章：开发环境搭建</strong></p><ul><li><a href="/CocosShader/cocos-shader-development-environment/" title="第2章：Cocos Shader开发环境搭建">第2章：Cocos Shader开发环境搭建</a></li><li>环境配置和工具介绍</li></ul></li><li><p><strong>第3章：语法介绍</strong></p><ul><li><a href="/CocosShader/cocos-shader-syntax-introduction/" title="第3章：Cocos Shader语法详解">第3章：Cocos Shader语法详解</a></li><li>Cocos Shader完整语法详解</li></ul></li><li><p><strong>第4章：PBR着色器基础</strong></p><ul><li><a href="/CocosShader/pbr-shader-fundamentals/" title="第4章：PBR着色器基础教程">第4章：PBR着色器基础教程</a></li><li>物理渲染基础理论</li></ul></li><li><p><strong>第5章：Surface Shader介绍</strong></p><ul><li><a href="/CocosShader/surface-shader-introduction/" title="第5章：Surface Shader深入介绍">第5章：Surface Shader深入介绍</a></li><li>Cocos Creator核心着色器系统</li></ul></li><li><p><strong>第9章：2D精灵着色器</strong></p><ul><li><a href="/CocosShader/2d-gradient-sprite-shader/" title="第9章：2D渐变精灵着色器实战">第9章：2D渐变精灵着色器实战</a></li><li>实战项目示例</li></ul></li></ol><h2 id="🗂️-项目结构"><a href="#🗂️-项目结构" class="headerlink" title="🗂️ 项目结构"></a>🗂️ 项目结构</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">source/_posts/CocosShader/</span><br><span class="line">├── cocos-creator-shader-complete-learning-guide.md  (7.0KB, 学习指南)</span><br><span class="line">├── cocos-shader-basics-concepts.md                  (6.6KB, 基础概念)</span><br><span class="line">├── cocos-shader-development-environment.md          (9.1KB, 环境搭建)</span><br><span class="line">├── cocos-shader-syntax-introduction.md              (11.7KB, 语法详解)</span><br><span class="line">├── pbr-shader-fundamentals.md                       (13.0KB, PBR基础)</span><br><span class="line">├── surface-shader-introduction.md                   (11.4KB, Surface Shader)</span><br><span class="line">├── 2d-gradient-sprite-shader.md                     (14.4KB, 2D特效)</span><br><span class="line">└── cocos-shader-series-summary.md                   (当前文件)</span><br><span class="line"></span><br><span class="line">source/images/cocosshader/                           (图片资源目录)</span><br></pre></td></tr></table></figure><h2 id="📖-学习路径规划"><a href="#📖-学习路径规划" class="headerlink" title="📖 学习路径规划"></a>📖 学习路径规划</h2><h3 id="🚀-入门篇（第1-3章）"><a href="#🚀-入门篇（第1-3章）" class="headerlink" title="🚀 入门篇（第1-3章）"></a>🚀 入门篇（第1-3章）</h3><ul><li><input checked="" disabled="" type="checkbox"> 第1章：基础概念与环境搭建 </li><li><input checked="" disabled="" type="checkbox"> 第2章：开发环境搭建</li><li><input checked="" disabled="" type="checkbox"> 第3章：Cocos Shader语法详解</li></ul><h3 id="🎨-进阶篇（第4-7章）"><a href="#🎨-进阶篇（第4-7章）" class="headerlink" title="🎨 进阶篇（第4-7章）"></a>🎨 进阶篇（第4-7章）</h3><ul><li><input checked="" disabled="" type="checkbox"> 第4章：PBR着色器基础</li><li><input checked="" disabled="" type="checkbox"> 第5章：Surface Shader深入</li><li><input disabled="" type="checkbox"> 第6章：光照模型与材质</li><li><input disabled="" type="checkbox"> 第7章：宏定义与函数重映射</li></ul><h3 id="🔧-实战篇（第8-11章）"><a href="#🔧-实战篇（第8-11章）" class="headerlink" title="🔧 实战篇（第8-11章）"></a>🔧 实战篇（第8-11章）</h3><ul><li><input disabled="" type="checkbox"> 第8章：自定义Surface Shader</li><li><input checked="" disabled="" type="checkbox"> 第9章：2D着色器特效</li><li><input disabled="" type="checkbox"> 第10章：3D高级特效</li><li><input disabled="" type="checkbox"> 第11章：渲染管线与优化</li></ul><h3 id="🏆-高级篇（第12-15章）"><a href="#🏆-高级篇（第12-15章）" class="headerlink" title="🏆 高级篇（第12-15章）"></a>🏆 高级篇（第12-15章）</h3><ul><li><input disabled="" type="checkbox"> 第12章：Legacy Shader详解</li><li><input disabled="" type="checkbox"> 第13章：高级渲染技术</li><li><input disabled="" type="checkbox"> 第14章：跨平台兼容性</li><li><input disabled="" type="checkbox"> 第15章：工具与工作流</li></ul><h2 id="🔧-技术特点"><a href="#🔧-技术特点" class="headerlink" title="🔧 技术特点"></a>🔧 技术特点</h2><h3 id="基于官方文档"><a href="#基于官方文档" class="headerlink" title="基于官方文档"></a>基于官方文档</h3><ul><li>完全对应<a href="https://docs.cocos.com/creator/3.8/manual/zh/shader/">Cocos Creator 3.8 Shader文档</a></li><li>包含所有官方特性介绍</li><li>适合新手到高级的完整学习路径</li></ul><h3 id="实战导向"><a href="#实战导向" class="headerlink" title="实战导向"></a>实战导向</h3><ul><li>每章包含实际代码示例</li><li>从简单效果到复杂特效</li><li>涵盖2D和3D渲染场景</li></ul><h3 id="系统性强"><a href="#系统性强" class="headerlink" title="系统性强"></a>系统性强</h3><ul><li>15章60+篇文章的完整体系</li><li>循序渐进的学习安排</li><li>相互关联的知识点</li></ul><h2 id="🎯-适合人群"><a href="#🎯-适合人群" class="headerlink" title="🎯 适合人群"></a>🎯 适合人群</h2><ul><li><strong>游戏开发新手</strong>: 从零学习着色器编程</li><li><strong>Cocos Creator开发者</strong>: 深入掌握渲染技术</li><li><strong>图形程序员</strong>: 了解Cocos Shader特性</li><li><strong>技术美术</strong>: 实现各种视觉效果</li></ul><h2 id="📊-内容覆盖"><a href="#📊-内容覆盖" class="headerlink" title="📊 内容覆盖"></a>📊 内容覆盖</h2><h3 id="核心技术点"><a href="#核心技术点" class="headerlink" title="核心技术点"></a>核心技术点</h3><ul><li>✅ 着色器基础概念和原理</li><li>✅ Cocos Creator渲染系统</li><li>✅ Surface Shader vs Legacy Shader</li><li>✅ PBR物理渲染</li><li>✅ 2D&#x2F;3D特效实现</li><li>✅ 性能优化技巧</li></ul><h3 id="实战项目"><a href="#实战项目" class="headerlink" title="实战项目"></a>实战项目</h3><ul><li>✅ 渐变精灵着色器</li><li><input disabled="" type="checkbox"> 水面波浪效果</li><li><input disabled="" type="checkbox"> 卡通渲染系统</li><li><input disabled="" type="checkbox"> 边缘光特效</li><li><input disabled="" type="checkbox"> 溶解消失效果</li><li><input disabled="" type="checkbox"> 全息投影材质</li></ul><h2 id="🛠️-开发配置"><a href="#🛠️-开发配置" class="headerlink" title="🛠️ 开发配置"></a>🛠️ 开发配置</h2><h3 id="项目集成"><a href="#项目集成" class="headerlink" title="项目集成"></a>项目集成</h3><ul><li>已添加<code>CocosShader</code>到博客分类</li><li>更新了文章创建脚本支持新分类</li><li>创建了专门的图片资源目录</li></ul><h3 id="博客系统"><a href="#博客系统" class="headerlink" title="博客系统"></a>博客系统</h3><ul><li>使用Hexo + Butterfly主题</li><li>支持代码高亮和数学公式</li><li>内部链接系统完善</li></ul><h2 id="🚀-下一步计划"><a href="#🚀-下一步计划" class="headerlink" title="🚀 下一步计划"></a>🚀 下一步计划</h2><ol><li><p><strong>完善核心文章</strong></p><ul><li>✅ 补充开发环境搭建详细步骤</li><li>✅ 完善Surface Shader介绍</li><li>✅ 添加更多实战示例</li></ul></li><li><p><strong>创建剩余文章</strong></p><ul><li>按学习路径继续创建文章</li><li>每篇文章包含完整的理论和实践</li></ul></li><li><p><strong>资源准备</strong></p><ul><li>制作配套图片和示例</li><li>录制教学视频（可选）</li><li>准备示例项目</li></ul></li><li><p><strong>社区推广</strong></p><ul><li>发布到Cocos Creator社区</li><li>技术博客平台分享</li><li>与开发者交流反馈</li></ul></li></ol><h2 id="💡-特色亮点"><a href="#💡-特色亮点" class="headerlink" title="💡 特色亮点"></a>💡 特色亮点</h2><ul><li><strong>官方权威</strong>: 基于Cocos Creator官方文档</li><li><strong>系统完整</strong>: 15章60+篇的完整学习体系</li><li><strong>实战丰富</strong>: 每章都有具体的代码实例</li><li><strong>新手友好</strong>: 从零开始的学习路径</li><li><strong>持续更新</strong>: 跟随官方版本更新</li></ul><h2 id="🎉-成果展示"><a href="#🎉-成果展示" class="headerlink" title="🎉 成果展示"></a>🎉 成果展示</h2><p>通过这个系列，读者可以：</p><ul><li>🎯 掌握Cocos Creator着色器开发</li><li>🚀 实现各种视觉特效</li><li>💡 理解现代渲染技术</li><li>🛠️ 具备独立开发能力</li></ul><hr><blockquote><p><strong>项目完成日期</strong>: 2024年12月<br><strong>预计完整更新</strong>: 2025年第一季度<br><strong>目标</strong>: 成为最全面的Cocos Creator Shader中文教程 </p></blockquote>]]></content>
      
      
      <categories>
          
          <category> CocosShader </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CocosShader </tag>
            
            <tag> Learning Guide </tag>
            
            <tag> Project Summary </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第5章：Surface Shader深入介绍</title>
      <link href="//CocosShader/surface-shader-introduction/"/>
      <url>//CocosShader/surface-shader-introduction/</url>
      
        <content type="html"><![CDATA[<h1 id="第5章：Surface-Shader深入介绍"><a href="#第5章：Surface-Shader深入介绍" class="headerlink" title="第5章：Surface Shader深入介绍"></a>第5章：Surface Shader深入介绍</h1><p>Surface Shader是Cocos Creator中最重要的着色器类型，它提供了强大而灵活的材质创建方式。本章将深入介绍Surface Shader的核心概念、结构和使用方法。</p><span id="more"></span><h2 id="🎯-学习目标"><a href="#🎯-学习目标" class="headerlink" title="🎯 学习目标"></a>🎯 学习目标</h2><p>通过本章学习，你将掌握：</p><ul><li>Surface Shader的核心概念和优势</li><li>Surface Shader的基本结构和组成部分</li><li>如何创建和配置Surface Shader</li><li>Surface Shader vs Legacy Shader的区别</li></ul><h2 id="🌟-什么是Surface-Shader？"><a href="#🌟-什么是Surface-Shader？" class="headerlink" title="🌟 什么是Surface Shader？"></a>🌟 什么是Surface Shader？</h2><h3 id="Surface-Shader概念"><a href="#Surface-Shader概念" class="headerlink" title="Surface Shader概念"></a>Surface Shader概念</h3><p>Surface Shader是Cocos Creator 3.x中引入的新型着色器系统，它采用了<strong>声明式编程</strong>的思想，让开发者专注于<strong>表面材质属性</strong>的定义，而将复杂的光照计算交给引擎处理。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Surface Shader核心思想</span></span><br><span class="line">CCProgram surface-shader %&#123;</span><br><span class="line">  <span class="comment">// 只需要定义表面属性</span></span><br><span class="line">  <span class="type">void</span> surf(<span class="keyword">out</span> StandardSurface s) &#123;</span><br><span class="line">    s.albedo = baseColor;</span><br><span class="line">    s.metallic = metallicValue;</span><br><span class="line">    s.roughness = roughnessValue;</span><br><span class="line">    s.normal = normalFromTexture;</span><br><span class="line">    <span class="comment">// 光照计算由引擎自动处理</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;%</span><br></pre></td></tr></table></figure><h3 id="Surface-Shader的优势"><a href="#Surface-Shader的优势" class="headerlink" title="Surface Shader的优势"></a>Surface Shader的优势</h3><ol><li><p><strong>简化开发流程</strong></p><ul><li>自动处理复杂的光照计算</li><li>标准化的材质属性接口</li><li>减少重复代码编写</li></ul></li><li><p><strong>更好的兼容性</strong></p><ul><li>自动适配不同渲染管线</li><li>支持前向和延迟渲染</li><li>跨平台兼容性更好</li></ul></li><li><p><strong>易于维护</strong></p><ul><li>清晰的代码结构</li><li>标准化的函数接口</li><li>更好的调试支持</li></ul></li></ol><h2 id="🏗️-Surface-Shader基本结构"><a href="#🏗️-Surface-Shader基本结构" class="headerlink" title="🏗️ Surface Shader基本结构"></a>🏗️ Surface Shader基本结构</h2><h3 id="完整的Surface-Shader模板"><a href="#完整的Surface-Shader模板" class="headerlink" title="完整的Surface Shader模板"></a>完整的Surface Shader模板</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">CCEffect:</span></span><br><span class="line">  <span class="attr">techniques:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">opaque</span></span><br><span class="line">      <span class="attr">passes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">vert:</span> <span class="string">standard-vs</span></span><br><span class="line">          <span class="attr">frag:</span> <span class="string">standard-fs</span></span><br><span class="line">          <span class="attr">properties:</span> <span class="meta">&amp;props</span></span><br><span class="line">            <span class="comment"># 材质属性定义</span></span><br><span class="line">            <span class="attr">mainTexture:</span>    &#123; <span class="attr">value:</span> <span class="string">white</span> &#125;</span><br><span class="line">            <span class="attr">mainColor:</span>      &#123; <span class="attr">value:</span> [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>], <span class="attr">editor:</span> &#123; <span class="attr">type:</span> <span class="string">color</span> &#125; &#125;</span><br><span class="line">            <span class="attr">metallic:</span>       &#123; <span class="attr">value:</span> <span class="number">0.0</span>, <span class="attr">range:</span> [<span class="number">0</span>, <span class="number">1.0</span>] &#125;</span><br><span class="line">            <span class="attr">roughness:</span>      &#123; <span class="attr">value:</span> <span class="number">0.5</span>, <span class="attr">range:</span> [<span class="number">0</span>, <span class="number">1.0</span>] &#125;</span><br><span class="line">            <span class="attr">normalMap:</span>      &#123; <span class="attr">value:</span> <span class="string">normal</span> &#125;</span><br><span class="line">            <span class="attr">normalStrength:</span> &#123; <span class="attr">value:</span> <span class="number">1.0</span>, <span class="attr">range:</span> [<span class="number">0</span>, <span class="number">3.0</span>] &#125;</span><br><span class="line">          <span class="attr">migrations:</span> <span class="meta">&amp;migs</span></span><br><span class="line">            <span class="comment"># 版本迁移配置</span></span><br><span class="line">            <span class="attr">properties:</span></span><br><span class="line">              <span class="attr">mainColor:</span>    &#123; <span class="attr">formerlySerializedAs:</span> <span class="string">albedo</span> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="attr">shaders:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">standard-vs</span></span><br><span class="line">      <span class="attr">type:</span> <span class="string">vert</span></span><br><span class="line">      <span class="comment"># 顶点着色器程序</span></span><br><span class="line">      </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">standard-fs</span>  </span><br><span class="line">      <span class="attr">type:</span> <span class="string">frag</span></span><br><span class="line">      <span class="comment"># 片元着色器程序</span></span><br></pre></td></tr></table></figure><h3 id="核心组成部分"><a href="#核心组成部分" class="headerlink" title="核心组成部分"></a>核心组成部分</h3><h4 id="1-技术配置（Techniques）"><a href="#1-技术配置（Techniques）" class="headerlink" title="1. 技术配置（Techniques）"></a>1. 技术配置（Techniques）</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">techniques:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">opaque</span>           <span class="comment"># 不透明渲染技术</span></span><br><span class="line">    <span class="attr">passes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">vert:</span> <span class="string">standard-vs</span></span><br><span class="line">        <span class="attr">frag:</span> <span class="string">standard-fs</span></span><br><span class="line">        <span class="attr">properties:</span> <span class="meta">*props</span></span><br><span class="line">        </span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">transparent</span>      <span class="comment"># 透明渲染技术  </span></span><br><span class="line">    <span class="attr">passes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">vert:</span> <span class="string">standard-vs</span></span><br><span class="line">        <span class="attr">frag:</span> <span class="string">standard-fs</span></span><br><span class="line">        <span class="attr">blendState:</span></span><br><span class="line">          <span class="attr">targets:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">blend:</span> <span class="literal">true</span></span><br><span class="line">              <span class="attr">blendSrc:</span> <span class="string">src_alpha</span></span><br><span class="line">              <span class="attr">blendDst:</span> <span class="string">one_minus_src_alpha</span></span><br></pre></td></tr></table></figure><h4 id="2-着色器程序（Shaders）"><a href="#2-着色器程序（Shaders）" class="headerlink" title="2. 着色器程序（Shaders）"></a>2. 着色器程序（Shaders）</h4><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">CCProgram standard-vs %&#123;</span><br><span class="line">  <span class="keyword">precision</span> <span class="keyword">highp</span> <span class="type">float</span>;</span><br><span class="line">  <span class="meta">#include &lt;builtin/uniforms/cc-global&gt;</span></span><br><span class="line">  <span class="meta">#include &lt;common/common-define&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">in</span> <span class="type">vec3</span> a_position;</span><br><span class="line">  <span class="keyword">in</span> <span class="type">vec3</span> a_normal;</span><br><span class="line">  <span class="keyword">in</span> <span class="type">vec2</span> a_texCoord;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">out</span> <span class="type">vec3</span> v_worldPos;</span><br><span class="line">  <span class="keyword">out</span> <span class="type">vec3</span> v_worldNormal;</span><br><span class="line">  <span class="keyword">out</span> <span class="type">vec2</span> v_uv;</span><br><span class="line">  </span><br><span class="line">  <span class="type">vec4</span> vert() &#123;</span><br><span class="line">    StandardVertInput In;</span><br><span class="line">    CCVertInput(In);</span><br><span class="line">    </span><br><span class="line">    StandardVertOutput Out;</span><br><span class="line">    CCStandardSurfaceVertex(Out, In);</span><br><span class="line">    </span><br><span class="line">    v_worldPos = Out.worldPos;</span><br><span class="line">    v_worldNormal = Out.worldNormal;</span><br><span class="line">    v_uv = Out.uv;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> Out.clipPos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;%</span><br><span class="line"></span><br><span class="line">CCProgram standard-fs %&#123;</span><br><span class="line">  <span class="keyword">precision</span> <span class="keyword">highp</span> <span class="type">float</span>;</span><br><span class="line">  <span class="meta">#include &lt;builtin/uniforms/cc-global&gt;</span></span><br><span class="line">  <span class="meta">#include &lt;common/lighting-models/includes/standard&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">in</span> <span class="type">vec3</span> v_worldPos;</span><br><span class="line">  <span class="keyword">in</span> <span class="type">vec3</span> v_worldNormal;</span><br><span class="line">  <span class="keyword">in</span> <span class="type">vec2</span> v_uv;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">uniform</span> <span class="type">sampler2D</span> mainTexture;</span><br><span class="line">  <span class="keyword">uniform</span> StandardSurfaceUniforms &#123;</span><br><span class="line">    <span class="type">vec4</span> mainColor;</span><br><span class="line">    <span class="type">float</span> metallic;</span><br><span class="line">    <span class="type">float</span> roughness;</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="type">vec4</span> frag() &#123;</span><br><span class="line">    StandardSurface s;</span><br><span class="line">    s.position = v_worldPos;</span><br><span class="line">    s.normal = <span class="built_in">normalize</span>(v_worldNormal);</span><br><span class="line">    s.albedo = mainColor.rgb * <span class="built_in">texture</span>(mainTexture, v_uv).rgb;</span><br><span class="line">    s.metallic = metallic;</span><br><span class="line">    s.roughness = roughness;</span><br><span class="line">    s.occlusion = <span class="number">1.0</span>;</span><br><span class="line">    s.emissive = <span class="type">vec3</span>(<span class="number">0.0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="type">vec4</span> color = CCStandardSurfaceShading(s);</span><br><span class="line">    <span class="keyword">return</span> CCFragOutput(color);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;%</span><br></pre></td></tr></table></figure><h2 id="🎨-Surface-Shader材质属性"><a href="#🎨-Surface-Shader材质属性" class="headerlink" title="🎨 Surface Shader材质属性"></a>🎨 Surface Shader材质属性</h2><h3 id="标准材质属性"><a href="#标准材质属性" class="headerlink" title="标准材质属性"></a>标准材质属性</h3><p>Surface Shader定义了一套标准的材质属性接口：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct StandardSurface &#123;</span><br><span class="line">  <span class="type">vec3</span> position;      <span class="comment">// 世界空间位置</span></span><br><span class="line">  <span class="type">vec3</span> normal;        <span class="comment">// 世界空间法线</span></span><br><span class="line">  <span class="type">vec3</span> albedo;        <span class="comment">// 反照率颜色</span></span><br><span class="line">  <span class="type">float</span> metallic;     <span class="comment">// 金属度 [0-1]</span></span><br><span class="line">  <span class="type">float</span> roughness;    <span class="comment">// 粗糙度 [0-1]  </span></span><br><span class="line">  <span class="type">float</span> occlusion;    <span class="comment">// 环境遮蔽 [0-1]</span></span><br><span class="line">  <span class="type">vec3</span> emissive;      <span class="comment">// 自发光颜色</span></span><br><span class="line">  <span class="type">float</span> alpha;        <span class="comment">// 透明度 [0-1]</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="PBR材质参数详解"><a href="#PBR材质参数详解" class="headerlink" title="PBR材质参数详解"></a>PBR材质参数详解</h3><h4 id="1-反照率（Albedo）"><a href="#1-反照率（Albedo）" class="headerlink" title="1. 反照率（Albedo）"></a>1. 反照率（Albedo）</h4><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 反照率定义了材质的基础颜色</span></span><br><span class="line">s.albedo = mainColor.rgb * <span class="built_in">texture</span>(mainTexture, v_uv).rgb;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于金属材质，反照率即为镜面反射颜色</span></span><br><span class="line"><span class="comment">// 对于非金属材质，反照率为漫反射颜色</span></span><br></pre></td></tr></table></figure><h4 id="2-金属度（Metallic）"><a href="#2-金属度（Metallic）" class="headerlink" title="2. 金属度（Metallic）"></a>2. 金属度（Metallic）</h4><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 金属度控制材质的导电性</span></span><br><span class="line">s.metallic = metallicValue * <span class="built_in">texture</span>(metallicMap, v_uv).r;</span><br><span class="line"></span><br><span class="line"><span class="comment">// metallic = 0.0 -&gt; 非金属（绝缘体）</span></span><br><span class="line"><span class="comment">// metallic = 1.0 -&gt; 纯金属（导体）</span></span><br><span class="line"><span class="comment">// 中间值通常用于氧化金属或脏污表面</span></span><br></pre></td></tr></table></figure><h4 id="3-粗糙度（Roughness）"><a href="#3-粗糙度（Roughness）" class="headerlink" title="3. 粗糙度（Roughness）"></a>3. 粗糙度（Roughness）</h4><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 粗糙度控制表面的微观几何细节</span></span><br><span class="line">s.roughness = roughnessValue * <span class="built_in">texture</span>(roughnessMap, v_uv).r;</span><br><span class="line"></span><br><span class="line"><span class="comment">// roughness = 0.0 -&gt; 完全光滑（镜面反射）</span></span><br><span class="line"><span class="comment">// roughness = 1.0 -&gt; 完全粗糙（漫反射）</span></span><br></pre></td></tr></table></figure><h4 id="4-法线贴图（Normal-Mapping）"><a href="#4-法线贴图（Normal-Mapping）" class="headerlink" title="4. 法线贴图（Normal Mapping）"></a>4. 法线贴图（Normal Mapping）</h4><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 法线贴图增加表面细节</span></span><br><span class="line"><span class="type">vec3</span> normalTS = <span class="built_in">texture</span>(normalMap, v_uv).xyz * <span class="number">2.0</span> - <span class="number">1.0</span>;</span><br><span class="line">normalTS.xy *= normalStrength;</span><br><span class="line">s.normal = <span class="built_in">normalize</span>(TBN * normalTS);</span><br></pre></td></tr></table></figure><h2 id="🔄-Surface-Shader执行流程"><a href="#🔄-Surface-Shader执行流程" class="headerlink" title="🔄 Surface Shader执行流程"></a>🔄 Surface Shader执行流程</h2><h3 id="渲染管线中的位置"><a href="#渲染管线中的位置" class="headerlink" title="渲染管线中的位置"></a>渲染管线中的位置</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    A[顶点数据] --&gt; B[顶点着色器]</span><br><span class="line">    B --&gt; C[图元装配]</span><br><span class="line">    C --&gt; D[光栅化]</span><br><span class="line">    D --&gt; E[Surface函数]</span><br><span class="line">    E --&gt; F[光照计算]</span><br><span class="line">    F --&gt; G[最终颜色]</span><br><span class="line">    </span><br><span class="line">    style E fill:#ff9999</span><br><span class="line">    style F fill:#99ccff</span><br></pre></td></tr></table></figure><h3 id="Surface函数调用时机"><a href="#Surface函数调用时机" class="headerlink" title="Surface函数调用时机"></a>Surface函数调用时机</h3><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Surface Shader的执行顺序</span></span><br><span class="line"><span class="type">vec4</span> frag() &#123;</span><br><span class="line">  <span class="comment">// 1. 准备输入数据</span></span><br><span class="line">  StandardSurface s;</span><br><span class="line">  s.position = v_worldPos;</span><br><span class="line">  s.normal = <span class="built_in">normalize</span>(v_worldNormal);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 2. 调用自定义surface函数</span></span><br><span class="line">  surf(s);  <span class="comment">// 用户定义的表面属性</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 3. 执行光照计算</span></span><br><span class="line">  <span class="type">vec4</span> color = CCStandardSurfaceShading(s);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 4. 后处理和输出</span></span><br><span class="line">  <span class="keyword">return</span> CCFragOutput(color);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="🆚-Surface-Shader-vs-Legacy-Shader"><a href="#🆚-Surface-Shader-vs-Legacy-Shader" class="headerlink" title="🆚 Surface Shader vs Legacy Shader"></a>🆚 Surface Shader vs Legacy Shader</h2><h3 id="主要区别对比"><a href="#主要区别对比" class="headerlink" title="主要区别对比"></a>主要区别对比</h3><table><thead><tr><th>特性</th><th>Surface Shader</th><th>Legacy Shader</th></tr></thead><tbody><tr><td><strong>编程方式</strong></td><td>声明式</td><td>命令式</td></tr><tr><td><strong>光照处理</strong></td><td>自动</td><td>手动</td></tr><tr><td><strong>代码复杂度</strong></td><td>简单</td><td>复杂</td></tr><tr><td><strong>维护成本</strong></td><td>低</td><td>高</td></tr><tr><td><strong>性能</strong></td><td>优化的</td><td>依赖实现</td></tr><tr><td><strong>兼容性</strong></td><td>更好</td><td>有限</td></tr></tbody></table><h3 id="使用场景选择"><a href="#使用场景选择" class="headerlink" title="使用场景选择"></a>使用场景选择</h3><p><strong>选择Surface Shader的情况：</strong></p><ul><li>标准PBR材质需求</li><li>需要完整的光照支持</li><li>追求开发效率</li><li>需要跨平台兼容</li></ul><p><strong>选择Legacy Shader的情况：</strong></p><ul><li>特殊的渲染效果</li><li>性能极致优化需求</li><li>自定义光照模型</li><li>后处理效果</li></ul><h2 id="🛠️-实践示例：创建简单Surface-Shader"><a href="#🛠️-实践示例：创建简单Surface-Shader" class="headerlink" title="🛠️ 实践示例：创建简单Surface Shader"></a>🛠️ 实践示例：创建简单Surface Shader</h2><h3 id="基础金属材质"><a href="#基础金属材质" class="headerlink" title="基础金属材质"></a>基础金属材质</h3><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">CCProgram metal-surface %&#123;</span><br><span class="line">  <span class="meta">#include &lt;common/lighting-models/includes/standard&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">uniform</span> MetalUniforms &#123;</span><br><span class="line">    <span class="type">vec4</span> baseColor;</span><br><span class="line">    <span class="type">float</span> metallic;</span><br><span class="line">    <span class="type">float</span> roughness;</span><br><span class="line">    <span class="type">float</span> reflectance;</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">uniform</span> <span class="type">sampler2D</span> albedoMap;</span><br><span class="line">  <span class="keyword">uniform</span> <span class="type">sampler2D</span> metallicRoughnessMap;</span><br><span class="line">  </span><br><span class="line">  <span class="type">void</span> surf(<span class="keyword">out</span> StandardSurface s) &#123;</span><br><span class="line">    <span class="type">vec4</span> albedoSample = <span class="built_in">texture</span>(albedoMap, v_uv);</span><br><span class="line">    <span class="type">vec4</span> metallicRoughness = <span class="built_in">texture</span>(metallicRoughnessMap, v_uv);</span><br><span class="line">    </span><br><span class="line">    s.albedo = baseColor.rgb * albedoSample.rgb;</span><br><span class="line">    s.metallic = metallic * metallicRoughness.b;</span><br><span class="line">    s.roughness = roughness * metallicRoughness.g;</span><br><span class="line">    s.occlusion = metallicRoughness.r;</span><br><span class="line">    s.emissive = <span class="type">vec3</span>(<span class="number">0.0</span>);</span><br><span class="line">    s.alpha = baseColor.a * albedoSample.a;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;%</span><br></pre></td></tr></table></figure><h3 id="自定义表面效果"><a href="#自定义表面效果" class="headerlink" title="自定义表面效果"></a>自定义表面效果</h3><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">CCProgram custom-surface %&#123;</span><br><span class="line">  <span class="meta">#include &lt;common/lighting-models/includes/standard&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">uniform</span> CustomUniforms &#123;</span><br><span class="line">    <span class="type">vec4</span> mainColor;</span><br><span class="line">    <span class="type">float</span> time;</span><br><span class="line">    <span class="type">float</span> waveStrength;</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="type">void</span> surf(<span class="keyword">out</span> StandardSurface s) &#123;</span><br><span class="line">    <span class="comment">// 动态UV扰动</span></span><br><span class="line">    <span class="type">vec2</span> distortedUV = v_uv + <span class="built_in">sin</span>(v_uv * <span class="number">10.0</span> + time) * waveStrength;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 基础材质属性</span></span><br><span class="line">    s.albedo = mainColor.rgb;</span><br><span class="line">    s.metallic = <span class="number">0.0</span>;</span><br><span class="line">    s.roughness = <span class="number">0.3</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 动态法线扰动</span></span><br><span class="line">    <span class="type">vec3</span> tangentNormal = <span class="type">vec3</span>(</span><br><span class="line">      <span class="built_in">sin</span>(distortedUV.x * <span class="number">20.0</span>) * <span class="number">0.1</span>,</span><br><span class="line">      <span class="built_in">sin</span>(distortedUV.y * <span class="number">20.0</span>) * <span class="number">0.1</span>,</span><br><span class="line">      <span class="number">1.0</span></span><br><span class="line">    );</span><br><span class="line">    s.normal = <span class="built_in">normalize</span>(TBN * tangentNormal);</span><br><span class="line">    </span><br><span class="line">    s.occlusion = <span class="number">1.0</span>;</span><br><span class="line">    s.emissive = <span class="type">vec3</span>(<span class="number">0.0</span>);</span><br><span class="line">    s.alpha = <span class="number">1.0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;%</span><br></pre></td></tr></table></figure><h2 id="🔧-调试和优化技巧"><a href="#🔧-调试和优化技巧" class="headerlink" title="🔧 调试和优化技巧"></a>🔧 调试和优化技巧</h2><h3 id="1-分组调试"><a href="#1-分组调试" class="headerlink" title="1. 分组调试"></a>1. 分组调试</h3><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用调试宏分别显示不同属性</span></span><br><span class="line"><span class="meta">#define DEBUG_ALBEDO 1</span></span><br><span class="line"><span class="meta">#define DEBUG_METALLIC 2  </span></span><br><span class="line"><span class="meta">#define DEBUG_ROUGHNESS 3</span></span><br><span class="line"><span class="meta">#define DEBUG_NORMAL 4</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#ifndef DEBUG_MODE</span></span><br><span class="line"><span class="meta">#define DEBUG_MODE 0</span></span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> surf(<span class="keyword">out</span> StandardSurface s) &#123;</span><br><span class="line">  <span class="comment">// 正常的surface计算...</span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#if DEBUG_MODE == DEBUG_ALBEDO</span></span><br><span class="line">  s.albedo = <span class="type">vec3</span>(<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>); <span class="comment">// 红色调试</span></span><br><span class="line">  s.metallic = <span class="number">0.0</span>;</span><br><span class="line">  s.roughness = <span class="number">1.0</span>;</span><br><span class="line"><span class="meta">#elif DEBUG_MODE == DEBUG_METALLIC</span></span><br><span class="line">  s.albedo = <span class="type">vec3</span>(s.metallic); <span class="comment">// 显示金属度</span></span><br><span class="line"><span class="meta">#elif DEBUG_MODE == DEBUG_ROUGHNESS  </span></span><br><span class="line">  s.albedo = <span class="type">vec3</span>(s.roughness); <span class="comment">// 显示粗糙度</span></span><br><span class="line"><span class="meta">#elif DEBUG_MODE == DEBUG_NORMAL</span></span><br><span class="line">  s.albedo = s.normal * <span class="number">0.5</span> + <span class="number">0.5</span>; <span class="comment">// 显示法线</span></span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-性能优化建议"><a href="#2-性能优化建议" class="headerlink" title="2. 性能优化建议"></a>2. 性能优化建议</h3><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ✅ 优化：减少纹理采样</span></span><br><span class="line"><span class="type">vec4</span> combinedTexture = <span class="built_in">texture</span>(metallicRoughnessOcclusionMap, v_uv);</span><br><span class="line">s.metallic = combinedTexture.r;</span><br><span class="line">s.roughness = combinedTexture.g;  </span><br><span class="line">s.occlusion = combinedTexture.b;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ❌ 避免：多次纹理采样</span></span><br><span class="line">s.metallic = <span class="built_in">texture</span>(metallicMap, v_uv).r;</span><br><span class="line">s.roughness = <span class="built_in">texture</span>(roughnessMap, v_uv).r;</span><br><span class="line">s.occlusion = <span class="built_in">texture</span>(occlusionMap, v_uv).r;</span><br></pre></td></tr></table></figure><h2 id="📚-本章总结"><a href="#📚-本章总结" class="headerlink" title="📚 本章总结"></a>📚 本章总结</h2><p>通过本章学习，我们深入了解了Surface Shader：</p><ul><li>✅ 理解了Surface Shader的核心概念和优势</li><li>✅ 掌握了Surface Shader的基本结构</li><li>✅ 学会了标准材质属性的使用方法</li><li>✅ 了解了Surface Shader的执行流程</li><li>✅ 掌握了调试和优化技巧</li></ul><h2 id="🚀-下一步"><a href="#🚀-下一步" class="headerlink" title="🚀 下一步"></a>🚀 下一步</h2><p>现在你已经掌握了Surface Shader的基础知识，接下来我们将学习更高级的Surface Shader技术：</p><p>👉 <strong><a href="!--swig%EF%BF%BC15--">第9章：2D渐变精灵着色器实战</a></strong></p><h2 id="💡-实践练习"><a href="#💡-实践练习" class="headerlink" title="💡 实践练习"></a>💡 实践练习</h2><ol><li><strong>基础练习</strong>: 创建一个简单的PBR材质Surface Shader</li><li><strong>进阶练习</strong>: 实现动态材质效果（如时间变化的roughness）</li><li><strong>调试练习</strong>: 使用调试模式验证各个材质属性</li></ol><hr><blockquote><p><strong>重要提示</strong>: Surface Shader是现代着色器开发的主流方向，建议重点掌握其使用方法和最佳实践。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> CocosShader </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CocosShader </tag>
            
            <tag> Surface Shader </tag>
            
            <tag> Advanced </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第2章：Cocos Shader开发环境搭建</title>
      <link href="//CocosShader/cocos-shader-development-environment/"/>
      <url>//CocosShader/cocos-shader-development-environment/</url>
      
        <content type="html"><![CDATA[<h1 id="第2章：Cocos-Shader开发环境搭建"><a href="#第2章：Cocos-Shader开发环境搭建" class="headerlink" title="第2章：Cocos Shader开发环境搭建"></a>第2章：Cocos Shader开发环境搭建</h1><p>工欲善其事，必先利其器。在开始Cocos Shader开发之前，我们需要搭建一个高效的开发环境。本章将详细介绍如何配置和优化Cocos Creator着色器的开发环境。</p><span id="more"></span><h2 id="🎯-学习目标"><a href="#🎯-学习目标" class="headerlink" title="🎯 学习目标"></a>🎯 学习目标</h2><p>通过本章学习，你将掌握：</p><ul><li>Cocos Creator开发环境的完整配置</li><li>VSCode着色器开发扩展的安装和使用</li><li>着色器调试工具的配置</li><li>开发工作流的最佳实践</li></ul><h2 id="💻-基础环境要求"><a href="#💻-基础环境要求" class="headerlink" title="💻 基础环境要求"></a>💻 基础环境要求</h2><h3 id="硬件要求"><a href="#硬件要求" class="headerlink" title="硬件要求"></a>硬件要求</h3><p><strong>最低配置：</strong></p><ul><li>CPU: Intel i5 &#x2F; AMD Ryzen 5 或同等性能</li><li>内存: 8GB RAM</li><li>显卡: 支持OpenGL 3.3 &#x2F; DirectX 11</li><li>存储: 10GB可用空间</li></ul><p><strong>推荐配置：</strong></p><ul><li>CPU: Intel i7 &#x2F; AMD Ryzen 7 或更高</li><li>内存: 16GB RAM 或更多</li><li>显卡: 独立显卡，支持OpenGL 4.5+</li><li>存储: SSD硬盘</li></ul><h3 id="操作系统支持"><a href="#操作系统支持" class="headerlink" title="操作系统支持"></a>操作系统支持</h3><ul><li><strong>Windows</strong>: Windows 10&#x2F;11 (64位)</li><li><strong>macOS</strong>: macOS 10.14+ </li><li><strong>Linux</strong>: Ubuntu 18.04+ &#x2F; CentOS 7+</li></ul><h2 id="🛠️-软件安装配置"><a href="#🛠️-软件安装配置" class="headerlink" title="🛠️ 软件安装配置"></a>🛠️ 软件安装配置</h2><h3 id="1-Cocos-Creator-安装"><a href="#1-Cocos-Creator-安装" class="headerlink" title="1. Cocos Creator 安装"></a>1. Cocos Creator 安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载Cocos Creator 3.8.x</span></span><br><span class="line"><span class="comment"># 访问官网：https://www.cocos.com/creator</span></span><br></pre></td></tr></table></figure><p><strong>安装步骤：</strong></p><ol><li>从<a href="https://www.cocos.com/creator">Cocos官网</a>下载最新版本</li><li>运行安装程序，选择安装路径</li><li>完成安装后启动Cocos Creator</li><li>注册&#x2F;登录Cocos开发者账号</li></ol><p><strong>重要设置：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 项目设置 -&gt; 项目数据 -&gt; 渲染管线</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;renderPipeline&quot;</span>: <span class="string">&quot;builtin-forward&quot;</span>, <span class="comment">// 前向渲染</span></span><br><span class="line">  <span class="string">&quot;customPipeline&quot;</span>: <span class="string">&quot;&quot;</span>,               <span class="comment">// 自定义管线</span></span><br><span class="line">  <span class="string">&quot;renderMode&quot;</span>: <span class="string">&quot;FORWARD&quot;</span>             <span class="comment">// 渲染模式</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-VSCode-配置"><a href="#2-VSCode-配置" class="headerlink" title="2. VSCode 配置"></a>2. VSCode 配置</h3><h4 id="安装VSCode"><a href="#安装VSCode" class="headerlink" title="安装VSCode"></a>安装VSCode</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Windows (使用winget)</span></span><br><span class="line">winget install Microsoft.VisualStudioCode</span><br><span class="line"></span><br><span class="line"><span class="comment"># macOS (使用Homebrew)</span></span><br><span class="line">brew install --cask visual-studio-code</span><br><span class="line"></span><br><span class="line"><span class="comment"># Linux (Ubuntu)</span></span><br><span class="line">sudo snap install code --classic</span><br></pre></td></tr></table></figure><h4 id="必装扩展"><a href="#必装扩展" class="headerlink" title="必装扩展"></a>必装扩展</h4><ol><li><p><strong>Cocos Creator Shader</strong> (官方扩展)</p><ul><li>语法高亮</li><li>代码补全</li><li>错误检查</li></ul></li><li><p><strong>GLSL Lint</strong> </p><ul><li>GLSL语法检查</li><li>实时错误提示</li></ul></li><li><p><strong>Shader languages support</strong></p><ul><li>多种着色器语言支持</li><li>语法高亮增强</li></ul></li></ol><h4 id="VSCode配置文件"><a href="#VSCode配置文件" class="headerlink" title="VSCode配置文件"></a>VSCode配置文件</h4><p>创建 <code>.vscode/settings.json</code>：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;glsllint.glslifyOptions&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;basedir&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;/assets/effects&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;files.associations&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;*.effect&quot;</span><span class="punctuation">:</span> <span class="string">&quot;yaml&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;*.chunk&quot;</span><span class="punctuation">:</span> <span class="string">&quot;glsl&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;editor.tabSize&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;editor.insertSpaces&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;glsl.validation&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="3-项目结构配置"><a href="#3-项目结构配置" class="headerlink" title="3. 项目结构配置"></a>3. 项目结构配置</h3><h4 id="标准目录结构"><a href="#标准目录结构" class="headerlink" title="标准目录结构"></a>标准目录结构</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">MyShaderProject/</span><br><span class="line">├── assets/</span><br><span class="line">│   ├── effects/          # 着色器文件</span><br><span class="line">│   │   ├── common/       # 通用着色器</span><br><span class="line">│   │   ├── surface/      # Surface Shader</span><br><span class="line">│   │   └── legacy/       # Legacy Shader</span><br><span class="line">│   ├── materials/        # 材质文件</span><br><span class="line">│   ├── textures/         # 纹理资源</span><br><span class="line">│   └── scenes/           # 场景文件</span><br><span class="line">├── packages/             # 扩展包</span><br><span class="line">└── settings/             # 项目设置</span><br></pre></td></tr></table></figure><h4 id="项目设置模板"><a href="#项目设置模板" class="headerlink" title="项目设置模板"></a>项目设置模板</h4><p>创建着色器项目时的推荐设置：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// project.json 关键配置</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;renderPipeline&quot;</span>: <span class="string">&quot;builtin-forward&quot;</span>,</span><br><span class="line">  <span class="string">&quot;groupList&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;name&quot;</span>: <span class="string">&quot;default&quot;</span>,</span><br><span class="line">      <span class="string">&quot;priority&quot;</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="string">&quot;index&quot;</span>: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;name&quot;</span>: <span class="string">&quot;ui&quot;</span>,</span><br><span class="line">      <span class="string">&quot;priority&quot;</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="string">&quot;index&quot;</span>: <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="🔧-开发工具配置"><a href="#🔧-开发工具配置" class="headerlink" title="🔧 开发工具配置"></a>🔧 开发工具配置</h2><h3 id="1-着色器编辑器设置"><a href="#1-着色器编辑器设置" class="headerlink" title="1. 着色器编辑器设置"></a>1. 着色器编辑器设置</h3><h4 id="Cocos-Creator内置编辑器"><a href="#Cocos-Creator内置编辑器" class="headerlink" title="Cocos Creator内置编辑器"></a>Cocos Creator内置编辑器</h4><ul><li><strong>路径</strong>: 资源管理器 -&gt; 右键 -&gt; 编辑</li><li><strong>功能</strong>: 语法高亮、实时预览、错误提示</li></ul><h4 id="外部编辑器配置"><a href="#外部编辑器配置" class="headerlink" title="外部编辑器配置"></a>外部编辑器配置</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置外部编辑器</span></span><br><span class="line"><span class="comment">// 偏好设置 -&gt; 数据编辑 -&gt; 外部脚本编辑器</span></span><br><span class="line"><span class="comment">// 路径：C:\Users\[用户名]\AppData\Local\Programs\Microsoft VS Code\Code.exe</span></span><br></pre></td></tr></table></figure><h3 id="2-调试工具配置"><a href="#2-调试工具配置" class="headerlink" title="2. 调试工具配置"></a>2. 调试工具配置</h3><h4 id="内置调试功能"><a href="#内置调试功能" class="headerlink" title="内置调试功能"></a>内置调试功能</h4><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调试宏定义</span></span><br><span class="line"><span class="meta">#define DEBUG_MODE 1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#if DEBUG_MODE</span></span><br><span class="line">  <span class="comment">// 调试代码</span></span><br><span class="line">  <span class="meta">#define DEBUG_COLOR(color) gl_FragColor = vec4(color, 1.0)</span></span><br><span class="line"><span class="meta">#else</span></span><br><span class="line">  <span class="meta">#define DEBUG_COLOR(color)</span></span><br><span class="line"><span class="meta">#endif</span></span><br></pre></td></tr></table></figure><h4 id="渲染调试器"><a href="#渲染调试器" class="headerlink" title="渲染调试器"></a>渲染调试器</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 启用渲染调试</span></span><br><span class="line"><span class="keyword">import</span> &#123; director, game &#125; <span class="keyword">from</span> <span class="string">&#x27;cc&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在游戏初始化时启用调试模式</span></span><br><span class="line">game.<span class="title function_">on</span>(<span class="string">&#x27;game-inited&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable constant_">CC_DEBUG</span>) &#123;</span><br><span class="line">    director.<span class="property">root</span>.<span class="property">debugView</span>.<span class="title function_">activate</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="3-性能分析工具"><a href="#3-性能分析工具" class="headerlink" title="3. 性能分析工具"></a>3. 性能分析工具</h3><h4 id="GPU性能监控"><a href="#GPU性能监控" class="headerlink" title="GPU性能监控"></a>GPU性能监控</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 性能统计</span></span><br><span class="line"><span class="keyword">import</span> &#123; profiler &#125; <span class="keyword">from</span> <span class="string">&#x27;cc&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启用性能监控</span></span><br><span class="line">profiler.<span class="title function_">showStats</span>();</span><br><span class="line">profiler.<span class="property">isShowingStats</span> = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><h4 id="着色器编译信息"><a href="#着色器编译信息" class="headerlink" title="着色器编译信息"></a>着色器编译信息</h4><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在effect文件中添加编译信息</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Shader Compilation Info:</span></span><br><span class="line"><span class="comment"> * - Target: WebGL 2.0</span></span><br><span class="line"><span class="comment"> * - Features: INSTANCING, BATCHING</span></span><br><span class="line"><span class="comment"> * - Variants: 16</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="📁-资源管理最佳实践"><a href="#📁-资源管理最佳实践" class="headerlink" title="📁 资源管理最佳实践"></a>📁 资源管理最佳实践</h2><h3 id="1-着色器文件命名规范"><a href="#1-着色器文件命名规范" class="headerlink" title="1. 着色器文件命名规范"></a>1. 着色器文件命名规范</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">命名格式：[类型]-[功能]-[版本].effect</span><br><span class="line">示例：</span><br><span class="line">- surface-pbr-standard.effect     # Surface PBR标准材质</span><br><span class="line">- legacy-unlit-transparent.effect # Legacy无光照透明</span><br><span class="line">- custom-water-v2.effect          # 自定义水面v2版本</span><br></pre></td></tr></table></figure><h3 id="2-材质资源组织"><a href="#2-材质资源组织" class="headerlink" title="2. 材质资源组织"></a>2. 材质资源组织</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">materials/</span><br><span class="line">├── common/           # 通用材质</span><br><span class="line">│   ├── standard.mtl</span><br><span class="line">│   └── unlit.mtl</span><br><span class="line">├── characters/       # 角色材质</span><br><span class="line">│   ├── skin.mtl</span><br><span class="line">│   └── cloth.mtl</span><br><span class="line">└── environment/      # 环境材质</span><br><span class="line">    ├── terrain.mtl</span><br><span class="line">    └── vegetation.mtl</span><br></pre></td></tr></table></figure><h3 id="3-版本控制配置"><a href="#3-版本控制配置" class="headerlink" title="3. 版本控制配置"></a>3. 版本控制配置</h3><h4 id="gitignore配置"><a href="#gitignore配置" class="headerlink" title=".gitignore配置"></a>.gitignore配置</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># Cocos Creator</span><br><span class="line">/library/</span><br><span class="line">/local/</span><br><span class="line">/temp/</span><br><span class="line">*.meta</span><br><span class="line"></span><br><span class="line"># 编译生成文件</span><br><span class="line">/build/</span><br><span class="line">/dist/</span><br><span class="line"></span><br><span class="line"># IDE文件</span><br><span class="line">.vscode/</span><br><span class="line">*.swp</span><br><span class="line">*.swo</span><br></pre></td></tr></table></figure><h2 id="🚀-开发工作流"><a href="#🚀-开发工作流" class="headerlink" title="🚀 开发工作流"></a>🚀 开发工作流</h2><h3 id="1-着色器开发流程"><a href="#1-着色器开发流程" class="headerlink" title="1. 着色器开发流程"></a>1. 着色器开发流程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    A[需求分析] --&gt; B[设计着色器]</span><br><span class="line">    B --&gt; C[编写代码]</span><br><span class="line">    C --&gt; D[测试调试]</span><br><span class="line">    D --&gt; E&#123;效果满意?&#125;</span><br><span class="line">    E --&gt;|否| C</span><br><span class="line">    E --&gt;|是| F[性能优化]</span><br><span class="line">    F --&gt; G[文档记录]</span><br></pre></td></tr></table></figure><h3 id="2-调试工作流"><a href="#2-调试工作流" class="headerlink" title="2. 调试工作流"></a>2. 调试工作流</h3><p><strong>Step 1: 基础验证</strong></p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最简单的颜色输出测试</span></span><br><span class="line">CCProgram fs %&#123;</span><br><span class="line">  <span class="keyword">out</span> <span class="type">vec4</span> fragColor;</span><br><span class="line">  <span class="type">void</span> main() &#123;</span><br><span class="line">    fragColor = <span class="type">vec4</span>(<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>); <span class="comment">// 红色测试</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;%</span><br></pre></td></tr></table></figure><p><strong>Step 2: 分步调试</strong></p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分别验证各个组件</span></span><br><span class="line"><span class="meta">#define DEBUG_STEP 1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#if DEBUG_STEP == 1</span></span><br><span class="line">  fragColor = <span class="type">vec4</span>(v_uv, <span class="number">0.0</span>, <span class="number">1.0</span>);     <span class="comment">// 显示UV</span></span><br><span class="line"><span class="meta">#elif DEBUG_STEP == 2  </span></span><br><span class="line">  fragColor = <span class="type">vec4</span>(normal * <span class="number">0.5</span> + <span class="number">0.5</span>, <span class="number">1.0</span>); <span class="comment">// 显示法线</span></span><br><span class="line"><span class="meta">#elif DEBUG_STEP == 3</span></span><br><span class="line">  fragColor = <span class="built_in">texture</span>(mainTexture, v_uv);     <span class="comment">// 显示纹理</span></span><br><span class="line"><span class="meta">#endif</span></span><br></pre></td></tr></table></figure><h3 id="3-性能测试工作流"><a href="#3-性能测试工作流" class="headerlink" title="3. 性能测试工作流"></a>3. 性能测试工作流</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 性能测试代码</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Material</span>, <span class="title class_">MeshRenderer</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;cc&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">ShaderPerformanceTest</span> &#123;</span><br><span class="line">  <span class="title function_">testShaderPerformance</span>(<span class="params">material: Material</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> startTime = performance.<span class="title function_">now</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 渲染测试</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">      <span class="comment">// 模拟渲染调用</span></span><br><span class="line">      material.<span class="title function_">setProperty</span>(<span class="string">&#x27;testValue&#x27;</span>, <span class="title class_">Math</span>.<span class="title function_">random</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> endTime = performance.<span class="title function_">now</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Shader performance: <span class="subst">$&#123;endTime - startTime&#125;</span>ms`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="🛡️-常见问题解决"><a href="#🛡️-常见问题解决" class="headerlink" title="🛡️ 常见问题解决"></a>🛡️ 常见问题解决</h2><h3 id="1-编译错误处理"><a href="#1-编译错误处理" class="headerlink" title="1. 编译错误处理"></a>1. 编译错误处理</h3><p><strong>问题</strong>: 着色器编译失败</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">解决方案：</span><br><span class="line">1. 检查语法错误</span><br><span class="line">2. 验证变量声明</span><br><span class="line">3. 确认函数调用正确</span><br><span class="line">4. 查看编译日志</span><br></pre></td></tr></table></figure><p><strong>调试技巧</strong>:</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用预处理器调试</span></span><br><span class="line"><span class="meta">#ifdef GL_ES</span></span><br><span class="line"><span class="keyword">precision</span> <span class="keyword">mediump</span> <span class="type">float</span>;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 分段注释调试</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">vec4 debugColor = vec4(1.0, 0.0, 0.0, 1.0);</span></span><br><span class="line"><span class="comment">gl_FragColor = debugColor;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="2-性能问题诊断"><a href="#2-性能问题诊断" class="headerlink" title="2. 性能问题诊断"></a>2. 性能问题诊断</h3><p><strong>常见性能问题</strong>:</p><ul><li>纹理采样过多</li><li>复杂的数学计算</li><li>动态分支语句</li></ul><p><strong>优化建议</strong>:</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 避免在fragment shader中使用复杂计算</span></span><br><span class="line"><span class="comment">// ❌ 错误示例</span></span><br><span class="line"><span class="type">float</span> complexValue = <span class="built_in">pow</span>(<span class="built_in">sin</span>(<span class="built_in">cos</span>(v_uv.x * <span class="number">10.0</span>)), <span class="number">2.0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ✅ 正确示例 - 预计算或查找表</span></span><br><span class="line"><span class="type">float</span> simpleValue = <span class="built_in">texture</span>(lookupTexture, <span class="type">vec2</span>(v_uv.x, <span class="number">0.0</span>)).r;</span><br></pre></td></tr></table></figure><h2 id="📚-本章总结"><a href="#📚-本章总结" class="headerlink" title="📚 本章总结"></a>📚 本章总结</h2><p>通过本章学习，我们建立了完整的Cocos Shader开发环境：</p><ul><li>✅ 安装配置了Cocos Creator和VSCode</li><li>✅ 设置了着色器开发扩展和调试工具  </li><li>✅ 建立了标准的项目结构和命名规范</li><li>✅ 掌握了高效的开发和调试工作流</li></ul><h2 id="🚀-下一步"><a href="#🚀-下一步" class="headerlink" title="🚀 下一步"></a>🚀 下一步</h2><p>环境搭建完成后，让我们开始创建第一个着色器：</p><p>👉 <strong><a href="!--swig%EF%BF%BC21--">第3章：Cocos Shader语法详解</a></strong></p><h2 id="💡-实践练习"><a href="#💡-实践练习" class="headerlink" title="💡 实践练习"></a>💡 实践练习</h2><ol><li><strong>环境验证</strong>: 创建一个新项目，测试着色器编辑功能</li><li><strong>工具熟悉</strong>: 尝试使用VSCode编辑和调试着色器</li><li><strong>性能测试</strong>: 运行性能监控工具，观察渲染数据</li></ol><hr><blockquote><p><strong>提示</strong>: 开发环境的配置是一次性投入，但会极大提升后续的开发效率。建议花足够时间完善配置。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> CocosShader </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CocosShader </tag>
            
            <tag> Environment </tag>
            
            <tag> Setup </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第4章：PBR着色器基础教程</title>
      <link href="//CocosShader/pbr-shader-fundamentals/"/>
      <url>//CocosShader/pbr-shader-fundamentals/</url>
      
        <content type="html"><![CDATA[<h1 id="第4章：PBR着色器基础教程"><a href="#第4章：PBR着色器基础教程" class="headerlink" title="第4章：PBR着色器基础教程"></a>第4章：PBR着色器基础教程</h1><p>基于物理的渲染（Physically Based Rendering，PBR）是现代3D图形渲染的标准方法。本章将详细介绍PBR的基本概念、数学原理以及在Cocos Creator中的实现方法。</p><span id="more"></span><h2 id="🎯-学习目标"><a href="#🎯-学习目标" class="headerlink" title="🎯 学习目标"></a>🎯 学习目标</h2><p>通过本章学习，你将掌握：</p><ul><li>PBR渲染的基本概念和物理原理</li><li>材质属性的物理意义和使用方法</li><li>在Cocos Creator中创建PBR材质</li><li>PBR着色器的实现和优化技巧</li></ul><h2 id="🌟-什么是PBR？"><a href="#🌟-什么是PBR？" class="headerlink" title="🌟 什么是PBR？"></a>🌟 什么是PBR？</h2><h3 id="PBR的核心思想"><a href="#PBR的核心思想" class="headerlink" title="PBR的核心思想"></a>PBR的核心思想</h3><p>基于物理的渲染（PBR）是一种尝试以物理正确的方式来渲染图形的方法。PBR的核心思想是：</p><ul><li><strong>能量守恒</strong>：反射的光不能超过入射的光</li><li><strong>物理准确</strong>：材质参数基于现实世界的物理属性</li><li><strong>一致性</strong>：在不同光照条件下材质表现一致</li></ul><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PBR的核心方程（简化版）</span></span><br><span class="line"><span class="type">vec3</span> BRDF(<span class="type">vec3</span> lightDir, <span class="type">vec3</span> viewDir, <span class="type">vec3</span> normal) &#123;</span><br><span class="line">    <span class="type">vec3</span> diffuse = albedo * diffuseBRDF(lightDir, normal);</span><br><span class="line">    <span class="type">vec3</span> specular = specularBRDF(lightDir, viewDir, normal, roughness, metallic);</span><br><span class="line">    <span class="keyword">return</span> diffuse + specular;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="PBR-vs-传统渲染"><a href="#PBR-vs-传统渲染" class="headerlink" title="PBR vs 传统渲染"></a>PBR vs 传统渲染</h3><table><thead><tr><th>传统渲染</th><th>PBR渲染</th></tr></thead><tbody><tr><td>经验模型</td><td>物理模型</td></tr><tr><td>参数抽象</td><td>参数直观</td></tr><tr><td>不同光照下表现不一致</td><td>表现一致</td></tr><tr><td>调试困难</td><td>易于调试</td></tr></tbody></table><h2 id="🎨-PBR材质属性详解"><a href="#🎨-PBR材质属性详解" class="headerlink" title="🎨 PBR材质属性详解"></a>🎨 PBR材质属性详解</h2><h3 id="1-反照率（Albedo）"><a href="#1-反照率（Albedo）" class="headerlink" title="1. 反照率（Albedo）"></a>1. 反照率（Albedo）</h3><p>反照率定义了材质的基础颜色，但在PBR中有特殊含义：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 反照率的物理意义</span></span><br><span class="line"><span class="comment">// 对于电介质（非金属）：漫反射颜色</span></span><br><span class="line"><span class="comment">// 对于导体（金属）：镜面反射颜色</span></span><br><span class="line"></span><br><span class="line"><span class="type">vec3</span> getAlbedo(<span class="type">float</span> metallic) &#123;</span><br><span class="line">    <span class="comment">// 非金属材质的反照率应该在暗灰色范围</span></span><br><span class="line">    <span class="type">vec3</span> dielectricAlbedo = baseColor.rgb; <span class="comment">// 通常 0.02-0.9</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 金属材质的反照率是镜面反射颜色</span></span><br><span class="line">    <span class="type">vec3</span> metallicAlbedo = baseColor.rgb; <span class="comment">// 通常 0.5-1.0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">mix</span>(dielectricAlbedo, metallicAlbedo, metallic);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>反照率的正确数值范围：</strong></p><ul><li><strong>非金属材质</strong>: 0.02-0.9 (线性空间)</li><li><strong>金属材质</strong>: 0.5-1.0 (线性空间)</li><li><strong>常见材料参考</strong>:<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">vec3</span> charcoal = <span class="type">vec3</span>(<span class="number">0.02</span>);      <span class="comment">// 木炭</span></span><br><span class="line"><span class="type">vec3</span> skin = <span class="type">vec3</span>(<span class="number">0.35</span>);          <span class="comment">// 皮肤</span></span><br><span class="line"><span class="type">vec3</span> concrete = <span class="type">vec3</span>(<span class="number">0.5</span>);       <span class="comment">// 混凝土</span></span><br><span class="line"><span class="type">vec3</span> snow = <span class="type">vec3</span>(<span class="number">0.9</span>);           <span class="comment">// 雪</span></span><br><span class="line"><span class="type">vec3</span> gold = <span class="type">vec3</span>(<span class="number">1.0</span>, <span class="number">0.8</span>, <span class="number">0.3</span>); <span class="comment">// 黄金</span></span><br><span class="line"><span class="type">vec3</span> silver = <span class="type">vec3</span>(<span class="number">0.95</span>);        <span class="comment">// 银</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="2-金属度（Metallic）"><a href="#2-金属度（Metallic）" class="headerlink" title="2. 金属度（Metallic）"></a>2. 金属度（Metallic）</h3><p>金属度控制材质是导体还是绝缘体：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 金属度的物理意义</span></span><br><span class="line"><span class="type">float</span> metallic = metallicValue; <span class="comment">// 0.0 = 绝缘体, 1.0 = 导体</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基于金属度计算镜面反射系数 F0</span></span><br><span class="line"><span class="type">vec3</span> calculateF0(<span class="type">vec3</span> albedo, <span class="type">float</span> metallic) &#123;</span><br><span class="line">    <span class="type">vec3</span> dielectricF0 = <span class="type">vec3</span>(<span class="number">0.04</span>); <span class="comment">// 大部分绝缘体的F0约为0.04</span></span><br><span class="line">    <span class="type">vec3</span> metallicF0 = albedo;       <span class="comment">// 金属的F0就是其反照率</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">mix</span>(dielectricF0, metallicF0, metallic);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>金属度的使用规则：</strong></p><ul><li><strong>0.0</strong>: 完全非金属（塑料、布料、皮肤等）</li><li><strong>1.0</strong>: 完全金属（铁、金、银等）</li><li><strong>中间值</strong>: 通常用于生锈或氧化的金属</li></ul><h3 id="3-粗糙度（Roughness）"><a href="#3-粗糙度（Roughness）" class="headerlink" title="3. 粗糙度（Roughness）"></a>3. 粗糙度（Roughness）</h3><p>粗糙度控制表面的微观几何：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 粗糙度的物理意义</span></span><br><span class="line"><span class="type">float</span> roughness = roughnessValue; <span class="comment">// 0.0 = 光滑, 1.0 = 粗糙</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 粗糙度影响镜面反射的分布</span></span><br><span class="line"><span class="type">float</span> DistributionGGX(<span class="type">vec3</span> N, <span class="type">vec3</span> H, <span class="type">float</span> roughness) &#123;</span><br><span class="line">    <span class="type">float</span> a = roughness * roughness;</span><br><span class="line">    <span class="type">float</span> a2 = a * a;</span><br><span class="line">    <span class="type">float</span> NdotH = <span class="built_in">max</span>(<span class="built_in">dot</span>(N, H), <span class="number">0.0</span>);</span><br><span class="line">    <span class="type">float</span> NdotH2 = NdotH * NdotH;</span><br><span class="line">    </span><br><span class="line">    <span class="type">float</span> num = a2;</span><br><span class="line">    <span class="type">float</span> denom = (NdotH2 * (a2 - <span class="number">1.0</span>) + <span class="number">1.0</span>);</span><br><span class="line">    denom = PI * denom * denom;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> num / denom;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>粗糙度的视觉效果：</strong></p><ul><li><strong>0.0</strong>: 完美镜面（镜子）</li><li><strong>0.1</strong>: 非常光滑（抛光金属）</li><li><strong>0.5</strong>: 中等粗糙（普通塑料）</li><li><strong>1.0</strong>: 非常粗糙（布料、混凝土）</li></ul><h3 id="4-环境遮蔽（Ambient-Occlusion）"><a href="#4-环境遮蔽（Ambient-Occlusion）" class="headerlink" title="4. 环境遮蔽（Ambient Occlusion）"></a>4. 环境遮蔽（Ambient Occlusion）</h3><p>环境遮蔽模拟几何体对环境光的遮挡：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 环境遮蔽的应用</span></span><br><span class="line"><span class="type">vec3</span> applyAO(<span class="type">vec3</span> color, <span class="type">float</span> ao) &#123;</span><br><span class="line">    <span class="comment">// 只影响环境光，不影响直接光照</span></span><br><span class="line">    <span class="type">vec3</span> ambientLight = cc_ambientSky.rgb * color;</span><br><span class="line">    ambientLight *= ao;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ambientLight;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="📐-PBR数学原理"><a href="#📐-PBR数学原理" class="headerlink" title="📐 PBR数学原理"></a>📐 PBR数学原理</h2><h3 id="双向反射分布函数（BRDF）"><a href="#双向反射分布函数（BRDF）" class="headerlink" title="双向反射分布函数（BRDF）"></a>双向反射分布函数（BRDF）</h3><p>BRDF描述了光线如何从表面反射：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Cook-Torrance BRDF</span></span><br><span class="line"><span class="type">vec3</span> CookTorranceBRDF(<span class="type">vec3</span> lightDir, <span class="type">vec3</span> viewDir, <span class="type">vec3</span> normal, </span><br><span class="line">                      <span class="type">vec3</span> albedo, <span class="type">float</span> metallic, <span class="type">float</span> roughness) &#123;</span><br><span class="line">    <span class="type">vec3</span> halfway = <span class="built_in">normalize</span>(lightDir + viewDir);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 法线分布函数 (D)</span></span><br><span class="line">    <span class="type">float</span> D = DistributionGGX(normal, halfway, roughness);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 几何函数 (G)</span></span><br><span class="line">    <span class="type">float</span> G = GeometrySmith(normal, viewDir, lightDir, roughness);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 菲涅尔项 (F)</span></span><br><span class="line">    <span class="type">vec3</span> F0 = <span class="built_in">mix</span>(<span class="type">vec3</span>(<span class="number">0.04</span>), albedo, metallic);</span><br><span class="line">    <span class="type">vec3</span> F = fresnelSchlick(<span class="built_in">max</span>(<span class="built_in">dot</span>(halfway, viewDir), <span class="number">0.0</span>), F0);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 镜面反射项</span></span><br><span class="line">    <span class="type">vec3</span> numerator = D * G * F;</span><br><span class="line">    <span class="type">float</span> denominator = <span class="number">4.0</span> * <span class="built_in">max</span>(<span class="built_in">dot</span>(normal, viewDir), <span class="number">0.0</span>) * </span><br><span class="line">                             <span class="built_in">max</span>(<span class="built_in">dot</span>(normal, lightDir), <span class="number">0.0</span>) + <span class="number">0.0001</span>;</span><br><span class="line">    <span class="type">vec3</span> specular = numerator / denominator;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 漫反射项</span></span><br><span class="line">    <span class="type">vec3</span> kS = F;</span><br><span class="line">    <span class="type">vec3</span> kD = <span class="type">vec3</span>(<span class="number">1.0</span>) - kS;</span><br><span class="line">    kD *= <span class="number">1.0</span> - metallic;</span><br><span class="line">    <span class="type">vec3</span> diffuse = kD * albedo / PI;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> diffuse + specular;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="菲涅尔反射"><a href="#菲涅尔反射" class="headerlink" title="菲涅尔反射"></a>菲涅尔反射</h3><p>菲涅尔效应描述了反射率随视角的变化：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Schlick菲涅尔近似</span></span><br><span class="line"><span class="type">vec3</span> fresnelSchlick(<span class="type">float</span> cosTheta, <span class="type">vec3</span> F0) &#123;</span><br><span class="line">    <span class="keyword">return</span> F0 + (<span class="number">1.0</span> - F0) * <span class="built_in">pow</span>(<span class="built_in">clamp</span>(<span class="number">1.0</span> - cosTheta, <span class="number">0.0</span>, <span class="number">1.0</span>), <span class="number">5.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带粗糙度的菲涅尔近似</span></span><br><span class="line"><span class="type">vec3</span> fresnelSchlickRoughness(<span class="type">float</span> cosTheta, <span class="type">vec3</span> F0, <span class="type">float</span> roughness) &#123;</span><br><span class="line">    <span class="keyword">return</span> F0 + (<span class="built_in">max</span>(<span class="type">vec3</span>(<span class="number">1.0</span> - roughness), F0) - F0) * </span><br><span class="line">           <span class="built_in">pow</span>(<span class="built_in">clamp</span>(<span class="number">1.0</span> - cosTheta, <span class="number">0.0</span>, <span class="number">1.0</span>), <span class="number">5.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="🛠️-Cocos-Creator中的PBR实现"><a href="#🛠️-Cocos-Creator中的PBR实现" class="headerlink" title="🛠️ Cocos Creator中的PBR实现"></a>🛠️ Cocos Creator中的PBR实现</h2><h3 id="标准PBR-Surface-Shader"><a href="#标准PBR-Surface-Shader" class="headerlink" title="标准PBR Surface Shader"></a>标准PBR Surface Shader</h3><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">CCEffect:</span><br><span class="line">  techniques:</span><br><span class="line">    - name: opaque</span><br><span class="line">      passes:</span><br><span class="line">        - vert: standard-vs</span><br><span class="line">          frag: pbr-fs</span><br><span class="line">          properties:</span><br><span class="line">            albedoMap:     &#123; value: white &#125;</span><br><span class="line">            metallicMap:   &#123; value: white &#125;</span><br><span class="line">            roughnessMap:  &#123; value: white &#125;</span><br><span class="line">            normalMap:     &#123; value: normal &#125;</span><br><span class="line">            aoMap:         &#123; value: white &#125;</span><br><span class="line">            </span><br><span class="line">            albedo:        &#123; value: [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>], editor: &#123; type: color &#125; &#125;</span><br><span class="line">            metallic:      &#123; value: <span class="number">0.0</span>, range: [<span class="number">0</span>, <span class="number">1</span>] &#125;</span><br><span class="line">            roughness:     &#123; value: <span class="number">0.5</span>, range: [<span class="number">0</span>, <span class="number">1</span>] &#125;</span><br><span class="line">            normalScale:   &#123; value: <span class="number">1.0</span>, range: [<span class="number">0</span>, <span class="number">3</span>] &#125;</span><br><span class="line"></span><br><span class="line">CCProgram pbr-fs %&#123;</span><br><span class="line">  <span class="keyword">precision</span> <span class="keyword">highp</span> <span class="type">float</span>;</span><br><span class="line">  <span class="meta">#include &lt;builtin/uniforms/cc-global&gt;</span></span><br><span class="line">  <span class="meta">#include &lt;common/lighting-models/includes/standard&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">in</span> <span class="type">vec3</span> v_worldPos;</span><br><span class="line">  <span class="keyword">in</span> <span class="type">vec3</span> v_worldNormal;</span><br><span class="line">  <span class="keyword">in</span> <span class="type">vec2</span> v_uv;</span><br><span class="line">  <span class="keyword">in</span> <span class="type">mat3</span> v_tbn;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">uniform</span> <span class="type">sampler2D</span> albedoMap;</span><br><span class="line">  <span class="keyword">uniform</span> <span class="type">sampler2D</span> metallicMap;</span><br><span class="line">  <span class="keyword">uniform</span> <span class="type">sampler2D</span> roughnessMap;</span><br><span class="line">  <span class="keyword">uniform</span> <span class="type">sampler2D</span> normalMap;</span><br><span class="line">  <span class="keyword">uniform</span> <span class="type">sampler2D</span> aoMap;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">uniform</span> PBRUniforms &#123;</span><br><span class="line">    <span class="type">vec4</span> albedo;</span><br><span class="line">    <span class="type">float</span> metallic;</span><br><span class="line">    <span class="type">float</span> roughness;</span><br><span class="line">    <span class="type">float</span> normalScale;</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="type">vec4</span> frag() &#123;</span><br><span class="line">    StandardSurface s;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 基础属性</span></span><br><span class="line">    s.position = v_worldPos;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 法线贴图</span></span><br><span class="line">    <span class="type">vec3</span> normalTS = <span class="built_in">texture</span>(normalMap, v_uv).xyz * <span class="number">2.0</span> - <span class="number">1.0</span>;</span><br><span class="line">    normalTS.xy *= normalScale;</span><br><span class="line">    s.normal = <span class="built_in">normalize</span>(v_tbn * normalTS);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 反照率</span></span><br><span class="line">    <span class="type">vec4</span> albedoSample = <span class="built_in">texture</span>(albedoMap, v_uv);</span><br><span class="line">    s.albedo = albedo.rgb * albedoSample.rgb;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 金属度和粗糙度</span></span><br><span class="line">    s.metallic = metallic * <span class="built_in">texture</span>(metallicMap, v_uv).r;</span><br><span class="line">    s.roughness = roughness * <span class="built_in">texture</span>(roughnessMap, v_uv).r;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 环境遮蔽</span></span><br><span class="line">    s.occlusion = <span class="built_in">texture</span>(aoMap, v_uv).r;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 自发光和透明度</span></span><br><span class="line">    s.emissive = <span class="type">vec3</span>(<span class="number">0.0</span>);</span><br><span class="line">    s.alpha = albedo.a * albedoSample.a;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 执行PBR光照计算</span></span><br><span class="line">    <span class="type">vec4</span> color = CCStandardSurfaceShading(s);</span><br><span class="line">    <span class="keyword">return</span> CCFragOutput(color);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;%</span><br></pre></td></tr></table></figure><h3 id="自定义PBR实现"><a href="#自定义PBR实现" class="headerlink" title="自定义PBR实现"></a>自定义PBR实现</h3><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">CCProgram custom-pbr-fs %&#123;</span><br><span class="line">  <span class="comment">// 自定义PBR实现</span></span><br><span class="line">  <span class="type">vec3</span> calculatePBR(<span class="type">vec3</span> albedo, <span class="type">float</span> metallic, <span class="type">float</span> roughness,</span><br><span class="line">                   <span class="type">vec3</span> normal, <span class="type">vec3</span> viewDir, <span class="type">vec3</span> lightDir, <span class="type">vec3</span> lightColor) &#123;</span><br><span class="line">    <span class="type">vec3</span> halfway = <span class="built_in">normalize</span>(lightDir + viewDir);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算基础反射率F0</span></span><br><span class="line">    <span class="type">vec3</span> F0 = <span class="built_in">mix</span>(<span class="type">vec3</span>(<span class="number">0.04</span>), albedo, metallic);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Cook-Torrance BRDF组件</span></span><br><span class="line">    <span class="type">float</span> NDF = DistributionGGX(normal, halfway, roughness);</span><br><span class="line">    <span class="type">float</span> G = GeometrySmith(normal, viewDir, lightDir, roughness);</span><br><span class="line">    <span class="type">vec3</span> F = fresnelSchlick(<span class="built_in">max</span>(<span class="built_in">dot</span>(halfway, viewDir), <span class="number">0.0</span>), F0);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算镜面反射</span></span><br><span class="line">    <span class="type">vec3</span> numerator = NDF * G * F;</span><br><span class="line">    <span class="type">float</span> denominator = <span class="number">4.0</span> * <span class="built_in">max</span>(<span class="built_in">dot</span>(normal, viewDir), <span class="number">0.0</span>) * </span><br><span class="line">                             <span class="built_in">max</span>(<span class="built_in">dot</span>(normal, lightDir), <span class="number">0.0</span>) + <span class="number">0.0001</span>;</span><br><span class="line">    <span class="type">vec3</span> specular = numerator / denominator;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算漫反射</span></span><br><span class="line">    <span class="type">vec3</span> kS = F;</span><br><span class="line">    <span class="type">vec3</span> kD = <span class="type">vec3</span>(<span class="number">1.0</span>) - kS;</span><br><span class="line">    kD *= <span class="number">1.0</span> - metallic;</span><br><span class="line">    <span class="type">vec3</span> diffuse = kD * albedo / PI;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 组合最终颜色</span></span><br><span class="line">    <span class="type">float</span> NdotL = <span class="built_in">max</span>(<span class="built_in">dot</span>(normal, lightDir), <span class="number">0.0</span>);</span><br><span class="line">    <span class="keyword">return</span> (diffuse + specular) * lightColor * NdotL;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;%</span><br></pre></td></tr></table></figure><h2 id="🎨-常见材质实现"><a href="#🎨-常见材质实现" class="headerlink" title="🎨 常见材质实现"></a>🎨 常见材质实现</h2><h3 id="1-金属材质"><a href="#1-金属材质" class="headerlink" title="1. 金属材质"></a>1. 金属材质</h3><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> setupMetalMaterial(<span class="keyword">out</span> StandardSurface s) &#123;</span><br><span class="line">    s.albedo = <span class="type">vec3</span>(<span class="number">0.7</span>, <span class="number">0.7</span>, <span class="number">0.8</span>);  <span class="comment">// 银色金属</span></span><br><span class="line">    s.metallic = <span class="number">1.0</span>;                <span class="comment">// 完全金属</span></span><br><span class="line">    s.roughness = <span class="number">0.1</span>;               <span class="comment">// 轻微粗糙</span></span><br><span class="line">    s.occlusion = <span class="number">1.0</span>;</span><br><span class="line">    s.emissive = <span class="type">vec3</span>(<span class="number">0.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-塑料材质"><a href="#2-塑料材质" class="headerlink" title="2. 塑料材质"></a>2. 塑料材质</h3><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> setupPlasticMaterial(<span class="keyword">out</span> StandardSurface s) &#123;</span><br><span class="line">    s.albedo = <span class="type">vec3</span>(<span class="number">0.8</span>, <span class="number">0.2</span>, <span class="number">0.2</span>);  <span class="comment">// 红色塑料</span></span><br><span class="line">    s.metallic = <span class="number">0.0</span>;                <span class="comment">// 完全非金属</span></span><br><span class="line">    s.roughness = <span class="number">0.3</span>;               <span class="comment">// 中等粗糙</span></span><br><span class="line">    s.occlusion = <span class="number">1.0</span>;</span><br><span class="line">    s.emissive = <span class="type">vec3</span>(<span class="number">0.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-皮肤材质"><a href="#3-皮肤材质" class="headerlink" title="3. 皮肤材质"></a>3. 皮肤材质</h3><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> setupSkinMaterial(<span class="keyword">out</span> StandardSurface s) &#123;</span><br><span class="line">    s.albedo = <span class="type">vec3</span>(<span class="number">0.9</span>, <span class="number">0.7</span>, <span class="number">0.6</span>);  <span class="comment">// 肤色</span></span><br><span class="line">    s.metallic = <span class="number">0.0</span>;                <span class="comment">// 非金属</span></span><br><span class="line">    s.roughness = <span class="number">0.6</span>;               <span class="comment">// 较粗糙</span></span><br><span class="line">    s.occlusion = <span class="number">1.0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 皮肤的次表面散射（简化）</span></span><br><span class="line">    <span class="type">vec3</span> subsurface = s.albedo * <span class="number">0.2</span>;</span><br><span class="line">    s.emissive = subsurface;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="📊-性能优化技巧"><a href="#📊-性能优化技巧" class="headerlink" title="📊 性能优化技巧"></a>📊 性能优化技巧</h2><h3 id="1-纹理优化"><a href="#1-纹理优化" class="headerlink" title="1. 纹理优化"></a>1. 纹理优化</h3><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用通道打包减少纹理采样</span></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> metallicRoughnessAO; <span class="comment">// R=金属度, G=粗糙度, B=AO</span></span><br><span class="line"></span><br><span class="line"><span class="type">vec4</span> materialProps = <span class="built_in">texture</span>(metallicRoughnessAO, v_uv);</span><br><span class="line">s.metallic = materialProps.r;</span><br><span class="line">s.roughness = materialProps.g;</span><br><span class="line">s.occlusion = materialProps.b;</span><br></pre></td></tr></table></figure><h3 id="2-计算优化"><a href="#2-计算优化" class="headerlink" title="2. 计算优化"></a>2. 计算优化</h3><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 预计算常用值</span></span><br><span class="line"><span class="type">float</span> NdotV = <span class="built_in">max</span>(<span class="built_in">dot</span>(normal, viewDir), <span class="number">0.0</span>);</span><br><span class="line"><span class="type">float</span> NdotL = <span class="built_in">max</span>(<span class="built_in">dot</span>(normal, lightDir), <span class="number">0.0</span>);</span><br><span class="line"><span class="type">float</span> HdotV = <span class="built_in">max</span>(<span class="built_in">dot</span>(halfway, viewDir), <span class="number">0.0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 避免重复计算</span></span><br><span class="line"><span class="type">float</span> roughness2 = roughness * roughness;</span><br><span class="line"><span class="type">float</span> roughness4 = roughness2 * roughness2;</span><br></pre></td></tr></table></figure><h3 id="3-移动端优化"><a href="#3-移动端优化" class="headerlink" title="3. 移动端优化"></a>3. 移动端优化</h3><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简化的移动端PBR</span></span><br><span class="line"><span class="type">vec3</span> mobilePBR(<span class="type">vec3</span> albedo, <span class="type">float</span> roughness, <span class="type">vec3</span> normal, <span class="type">vec3</span> lightDir) &#123;</span><br><span class="line">    <span class="type">float</span> NdotL = <span class="built_in">max</span>(<span class="built_in">dot</span>(normal, lightDir), <span class="number">0.0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 简化的镜面反射</span></span><br><span class="line">    <span class="type">vec3</span> specular = <span class="built_in">pow</span>(NdotL, <span class="number">32.0</span> / (roughness + <span class="number">0.1</span>)) * <span class="number">0.2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 漫反射</span></span><br><span class="line">    <span class="type">vec3</span> diffuse = albedo * NdotL;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> diffuse + specular;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="🔧-调试PBR材质"><a href="#🔧-调试PBR材质" class="headerlink" title="🔧 调试PBR材质"></a>🔧 调试PBR材质</h2><h3 id="材质验证工具"><a href="#材质验证工具" class="headerlink" title="材质验证工具"></a>材质验证工具</h3><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 材质属性可视化</span></span><br><span class="line"><span class="meta">#define VISUALIZE_ALBEDO 1</span></span><br><span class="line"><span class="meta">#define VISUALIZE_METALLIC 2</span></span><br><span class="line"><span class="meta">#define VISUALIZE_ROUGHNESS 3</span></span><br><span class="line"><span class="meta">#define VISUALIZE_NORMAL 4</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#define DEBUG_MODE VISUALIZE_ALBEDO</span></span><br><span class="line"></span><br><span class="line"><span class="type">vec4</span> debugOutput(StandardSurface s) &#123;</span><br><span class="line"><span class="meta">#if DEBUG_MODE == VISUALIZE_ALBEDO</span></span><br><span class="line">    <span class="keyword">return</span> <span class="type">vec4</span>(s.albedo, <span class="number">1.0</span>);</span><br><span class="line"><span class="meta">#elif DEBUG_MODE == VISUALIZE_METALLIC</span></span><br><span class="line">    <span class="keyword">return</span> <span class="type">vec4</span>(<span class="type">vec3</span>(s.metallic), <span class="number">1.0</span>);</span><br><span class="line"><span class="meta">#elif DEBUG_MODE == VISUALIZE_ROUGHNESS</span></span><br><span class="line">    <span class="keyword">return</span> <span class="type">vec4</span>(<span class="type">vec3</span>(s.roughness), <span class="number">1.0</span>);</span><br><span class="line"><span class="meta">#elif DEBUG_MODE == VISUALIZE_NORMAL</span></span><br><span class="line">    <span class="keyword">return</span> <span class="type">vec4</span>(s.normal * <span class="number">0.5</span> + <span class="number">0.5</span>, <span class="number">1.0</span>);</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">    <span class="keyword">return</span> <span class="type">vec4</span>(<span class="number">0.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="📚-本章总结"><a href="#📚-本章总结" class="headerlink" title="📚 本章总结"></a>📚 本章总结</h2><p>通过本章学习，我们深入了解了PBR渲染：</p><ul><li>✅ 理解了PBR的物理基础和核心概念</li><li>✅ 掌握了各个材质属性的物理意义</li><li>✅ 学会了在Cocos Creator中实现PBR材质</li><li>✅ 了解了PBR的数学原理和优化技巧</li></ul><h2 id="🚀-下一步"><a href="#🚀-下一步" class="headerlink" title="🚀 下一步"></a>🚀 下一步</h2><p>现在你已经掌握了PBR的基础知识，接下来我们将学习Surface Shader：</p><p>👉 <strong><a href="!--swig%EF%BF%BC17--">第5章：Surface Shader深入介绍</a></strong></p><h2 id="💡-实践练习"><a href="#💡-实践练习" class="headerlink" title="💡 实践练习"></a>💡 实践练习</h2><ol><li><strong>基础练习</strong>: 创建不同类型的PBR材质（金属、塑料、布料）</li><li><strong>进阶练习</strong>: 实现一个材质球查看器，可以调节PBR参数</li><li><strong>优化练习</strong>: 对比不同优化级别的PBR实现性能差异</li></ol><hr><blockquote><p><strong>重要提示</strong>: PBR是现代渲染的基础，理解其物理原理对着色器开发至关重要。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> CocosShader </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CocosShader </tag>
            
            <tag> PBR </tag>
            
            <tag> Physically Based Rendering </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第3章：Cocos Shader语法详解</title>
      <link href="//CocosShader/cocos-shader-syntax-introduction/"/>
      <url>//CocosShader/cocos-shader-syntax-introduction/</url>
      
        <content type="html"><![CDATA[<h1 id="第3章：Cocos-Shader语法详解"><a href="#第3章：Cocos-Shader语法详解" class="headerlink" title="第3章：Cocos Shader语法详解"></a>第3章：Cocos Shader语法详解</h1><p>Cocos Shader采用了独特的YAML + GLSL混合语法，本章将深入介绍Cocos Shader的语法结构、编写规则和最佳实践，为后续的着色器开发打下坚实基础。</p><span id="more"></span><h2 id="🎯-学习目标"><a href="#🎯-学习目标" class="headerlink" title="🎯 学习目标"></a>🎯 学习目标</h2><p>通过本章学习，你将掌握：</p><ul><li>Cocos Shader的整体语法结构</li><li>CCEffect配置的详细语法</li><li>CCProgram着色器程序的编写规则</li><li>属性定义和传递机制</li><li>内置函数和宏的使用方法</li></ul><h2 id="🏗️-Cocos-Shader整体结构"><a href="#🏗️-Cocos-Shader整体结构" class="headerlink" title="🏗️ Cocos Shader整体结构"></a>🏗️ Cocos Shader整体结构</h2><h3 id="基本文件结构"><a href="#基本文件结构" class="headerlink" title="基本文件结构"></a>基本文件结构</h3><p>Cocos Shader文件（.effect）由三个主要部分组成：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. CCEffect配置块</span></span><br><span class="line"><span class="attr">CCEffect:</span></span><br><span class="line">  <span class="attr">techniques:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">opaque</span></span><br><span class="line">      <span class="attr">passes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">vert:</span> <span class="string">vs-main</span></span><br><span class="line">          <span class="attr">frag:</span> <span class="string">fs-main</span></span><br><span class="line">          <span class="attr">properties:</span></span><br><span class="line">            <span class="comment"># 属性定义</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 顶点着色器程序</span></span><br><span class="line"><span class="string">CCProgram</span> <span class="string">vs-main</span> <span class="string">%&#123;</span></span><br><span class="line">  <span class="string">//</span> <span class="string">GLSL顶点着色器代码</span></span><br><span class="line"><span class="string">&#125;%</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 片元着色器程序  </span></span><br><span class="line"><span class="string">CCProgram</span> <span class="string">fs-main</span> <span class="string">%&#123;</span></span><br><span class="line">  <span class="string">//</span> <span class="string">GLSL片元着色器代码</span></span><br><span class="line"><span class="string">&#125;%</span></span><br></pre></td></tr></table></figure><h3 id="语法特点"><a href="#语法特点" class="headerlink" title="语法特点"></a>语法特点</h3><ol><li><strong>YAML配置语法</strong>：用于定义渲染状态和属性</li><li><strong>CCProgram语法</strong>：用于编写GLSL着色器代码</li><li><strong>预处理器支持</strong>：支持条件编译和宏定义</li><li><strong>内置函数库</strong>：提供丰富的工具函数</li></ol><h2 id="📋-CCEffect配置详解"><a href="#📋-CCEffect配置详解" class="headerlink" title="📋 CCEffect配置详解"></a>📋 CCEffect配置详解</h2><h3 id="Techniques技术配置"><a href="#Techniques技术配置" class="headerlink" title="Techniques技术配置"></a>Techniques技术配置</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">CCEffect:</span></span><br><span class="line">  <span class="attr">techniques:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">opaque</span>           <span class="comment"># 技术名称</span></span><br><span class="line">      <span class="attr">passes:</span>                <span class="comment"># 渲染通道列表</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">vert:</span> <span class="string">vs-main</span>      <span class="comment"># 顶点着色器名称</span></span><br><span class="line">          <span class="attr">frag:</span> <span class="string">fs-main</span>      <span class="comment"># 片元着色器名称</span></span><br><span class="line">          <span class="attr">phase:</span> <span class="string">forward</span>     <span class="comment"># 渲染阶段</span></span><br><span class="line">          <span class="attr">priority:</span> <span class="number">128</span>      <span class="comment"># 渲染优先级</span></span><br><span class="line">          <span class="attr">stage:</span> <span class="string">default</span>     <span class="comment"># 渲染阶段标识</span></span><br><span class="line">          </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">transparent</span>      <span class="comment"># 透明技术</span></span><br><span class="line">      <span class="attr">passes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">vert:</span> <span class="string">vs-main</span></span><br><span class="line">          <span class="attr">frag:</span> <span class="string">fs-main</span></span><br><span class="line">          <span class="attr">phase:</span> <span class="string">forward</span></span><br><span class="line">          <span class="attr">priority:</span> <span class="number">256</span></span><br><span class="line">          <span class="attr">blendState:</span>        <span class="comment"># 混合状态</span></span><br><span class="line">            <span class="attr">targets:</span></span><br><span class="line">              <span class="bullet">-</span> <span class="attr">blend:</span> <span class="literal">true</span></span><br><span class="line">                <span class="attr">blendSrc:</span> <span class="string">src_alpha</span></span><br><span class="line">                <span class="attr">blendDst:</span> <span class="string">one_minus_src_alpha</span></span><br></pre></td></tr></table></figure><h3 id="Pass渲染通道配置"><a href="#Pass渲染通道配置" class="headerlink" title="Pass渲染通道配置"></a>Pass渲染通道配置</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">passes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">vert:</span> <span class="string">vertex-shader-name</span></span><br><span class="line">    <span class="attr">frag:</span> <span class="string">fragment-shader-name</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 渲染状态配置</span></span><br><span class="line">    <span class="attr">rasterizerState:</span></span><br><span class="line">      <span class="attr">cullMode:</span> <span class="string">back</span>        <span class="comment"># 背面剔除</span></span><br><span class="line">      </span><br><span class="line">    <span class="attr">depthStencilState:</span></span><br><span class="line">      <span class="attr">depthTest:</span> <span class="literal">true</span>       <span class="comment"># 深度测试</span></span><br><span class="line">      <span class="attr">depthWrite:</span> <span class="literal">true</span>      <span class="comment"># 深度写入</span></span><br><span class="line">      </span><br><span class="line">    <span class="attr">blendState:</span></span><br><span class="line">      <span class="attr">targets:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">blend:</span> <span class="literal">true</span></span><br><span class="line">          <span class="attr">blendSrc:</span> <span class="string">src_alpha</span></span><br><span class="line">          <span class="attr">blendDst:</span> <span class="string">one_minus_src_alpha</span></span><br><span class="line">          </span><br><span class="line">    <span class="comment"># 动态状态</span></span><br><span class="line">    <span class="attr">dynamics:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">CC_USE_HDR</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">number</span></span><br><span class="line">        <span class="attr">value:</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="Properties属性定义"><a href="#Properties属性定义" class="headerlink" title="Properties属性定义"></a>Properties属性定义</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">properties:</span></span><br><span class="line">  <span class="comment"># 纹理属性</span></span><br><span class="line">  <span class="attr">mainTexture:</span></span><br><span class="line">    <span class="attr">value:</span> <span class="string">white</span>            <span class="comment"># 默认值</span></span><br><span class="line">    <span class="attr">editor:</span></span><br><span class="line">      <span class="attr">tooltip:</span> <span class="string">&quot;主纹理&quot;</span>     <span class="comment"># 编辑器提示</span></span><br><span class="line">      </span><br><span class="line">  <span class="comment"># 颜色属性  </span></span><br><span class="line">  <span class="attr">tintColor:</span></span><br><span class="line">    <span class="attr">value:</span> [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]    <span class="comment"># RGBA默认值</span></span><br><span class="line">    <span class="attr">editor:</span></span><br><span class="line">      <span class="attr">type:</span> <span class="string">color</span>          <span class="comment"># 编辑器类型</span></span><br><span class="line">      <span class="attr">tooltip:</span> <span class="string">&quot;着色颜色&quot;</span></span><br><span class="line">      </span><br><span class="line">  <span class="comment"># 数值属性</span></span><br><span class="line">  <span class="attr">intensity:</span></span><br><span class="line">    <span class="attr">value:</span> <span class="number">1.0</span>             <span class="comment"># 默认值</span></span><br><span class="line">    <span class="attr">range:</span> [<span class="number">0</span>, <span class="number">5.0</span>]        <span class="comment"># 取值范围</span></span><br><span class="line">    <span class="attr">editor:</span></span><br><span class="line">      <span class="attr">slide:</span> <span class="literal">true</span>          <span class="comment"># 滑动条</span></span><br><span class="line">      <span class="attr">tooltip:</span> <span class="string">&quot;强度&quot;</span></span><br><span class="line">      </span><br><span class="line">  <span class="comment"># 向量属性</span></span><br><span class="line">  <span class="attr">offset:</span></span><br><span class="line">    <span class="attr">value:</span> [<span class="number">0</span>, <span class="number">0</span>]          <span class="comment"># vec2默认值</span></span><br><span class="line">    <span class="attr">editor:</span></span><br><span class="line">      <span class="attr">tooltip:</span> <span class="string">&quot;偏移量&quot;</span></span><br></pre></td></tr></table></figure><h2 id="🔧-CCProgram着色器程序"><a href="#🔧-CCProgram着色器程序" class="headerlink" title="🔧 CCProgram着色器程序"></a>🔧 CCProgram着色器程序</h2><h3 id="顶点着色器基本结构"><a href="#顶点着色器基本结构" class="headerlink" title="顶点着色器基本结构"></a>顶点着色器基本结构</h3><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">CCProgram vs-main %&#123;</span><br><span class="line">  <span class="keyword">precision</span> <span class="keyword">highp</span> <span class="type">float</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 包含内置头文件</span></span><br><span class="line">  <span class="meta">#include &lt;builtin/uniforms/cc-global&gt;</span></span><br><span class="line">  <span class="meta">#include &lt;builtin/uniforms/cc-local&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 输入属性</span></span><br><span class="line">  <span class="keyword">in</span> <span class="type">vec3</span> a_position;      <span class="comment">// 顶点位置</span></span><br><span class="line">  <span class="keyword">in</span> <span class="type">vec3</span> a_normal;        <span class="comment">// 顶点法线</span></span><br><span class="line">  <span class="keyword">in</span> <span class="type">vec2</span> a_texCoord;      <span class="comment">// 纹理坐标</span></span><br><span class="line">  <span class="keyword">in</span> <span class="type">vec4</span> a_color;         <span class="comment">// 顶点颜色</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 输出变量</span></span><br><span class="line">  <span class="keyword">out</span> <span class="type">vec3</span> v_worldPos;     <span class="comment">// 世界空间位置</span></span><br><span class="line">  <span class="keyword">out</span> <span class="type">vec3</span> v_worldNormal;  <span class="comment">// 世界空间法线</span></span><br><span class="line">  <span class="keyword">out</span> <span class="type">vec2</span> v_uv;           <span class="comment">// UV坐标</span></span><br><span class="line">  <span class="keyword">out</span> <span class="type">vec4</span> v_color;        <span class="comment">// 顶点颜色</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 主函数</span></span><br><span class="line">  <span class="type">vec4</span> vert() &#123;</span><br><span class="line">    <span class="comment">// 计算世界空间位置</span></span><br><span class="line">    <span class="type">vec4</span> worldPos = cc_matWorld * <span class="type">vec4</span>(a_position, <span class="number">1.0</span>);</span><br><span class="line">    v_worldPos = worldPos.xyz;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算世界空间法线</span></span><br><span class="line">    v_worldNormal = <span class="built_in">normalize</span>((cc_matWorldIT * <span class="type">vec4</span>(a_normal, <span class="number">0.0</span>)).xyz);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 传递UV和颜色</span></span><br><span class="line">    v_uv = a_texCoord;</span><br><span class="line">    v_color = a_color;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算裁剪空间位置</span></span><br><span class="line">    <span class="keyword">return</span> cc_matViewProj * worldPos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;%</span><br></pre></td></tr></table></figure><h3 id="片元着色器基本结构"><a href="#片元着色器基本结构" class="headerlink" title="片元着色器基本结构"></a>片元着色器基本结构</h3><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">CCProgram fs-main %&#123;</span><br><span class="line">  <span class="keyword">precision</span> <span class="keyword">highp</span> <span class="type">float</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 包含内置头文件</span></span><br><span class="line">  <span class="meta">#include &lt;builtin/uniforms/cc-global&gt;</span></span><br><span class="line">  <span class="meta">#include &lt;common/lighting/standard&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 输入变量（来自顶点着色器）</span></span><br><span class="line">  <span class="keyword">in</span> <span class="type">vec3</span> v_worldPos;</span><br><span class="line">  <span class="keyword">in</span> <span class="type">vec3</span> v_worldNormal;</span><br><span class="line">  <span class="keyword">in</span> <span class="type">vec2</span> v_uv;</span><br><span class="line">  <span class="keyword">in</span> <span class="type">vec4</span> v_color;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 纹理采样器</span></span><br><span class="line">  <span class="keyword">uniform</span> <span class="type">sampler2D</span> mainTexture;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 自定义uniform块</span></span><br><span class="line">  <span class="keyword">uniform</span> MaterialUniforms &#123;</span><br><span class="line">    <span class="type">vec4</span> tintColor;</span><br><span class="line">    <span class="type">float</span> intensity;</span><br><span class="line">    <span class="type">vec2</span> <span class="keyword">offset</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 主函数</span></span><br><span class="line">  <span class="type">vec4</span> frag() &#123;</span><br><span class="line">    <span class="comment">// 纹理采样</span></span><br><span class="line">    <span class="type">vec4</span> texColor = <span class="built_in">texture</span>(mainTexture, v_uv + <span class="keyword">offset</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 颜色计算</span></span><br><span class="line">    <span class="type">vec4</span> finalColor = texColor * tintColor * v_color;</span><br><span class="line">    finalColor.rgb *= intensity;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> finalColor;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;%</span><br></pre></td></tr></table></figure><h2 id="📚-内置头文件和函数"><a href="#📚-内置头文件和函数" class="headerlink" title="📚 内置头文件和函数"></a>📚 内置头文件和函数</h2><h3 id="常用内置头文件"><a href="#常用内置头文件" class="headerlink" title="常用内置头文件"></a>常用内置头文件</h3><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局uniform（时间、屏幕信息等）</span></span><br><span class="line"><span class="meta">#include &lt;builtin/uniforms/cc-global&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 本地变换矩阵</span></span><br><span class="line"><span class="meta">#include &lt;builtin/uniforms/cc-local&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 光照相关</span></span><br><span class="line"><span class="meta">#include &lt;builtin/uniforms/cc-forward-light&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 阴影相关</span></span><br><span class="line"><span class="meta">#include &lt;builtin/uniforms/cc-shadow&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通用定义和工具函数</span></span><br><span class="line"><span class="meta">#include &lt;common/common-define&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数学工具函数</span></span><br><span class="line"><span class="meta">#include &lt;common/math/number&gt;</span></span><br><span class="line"><span class="meta">#include &lt;common/math/coordinates&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 纹理相关工具</span></span><br><span class="line"><span class="meta">#include &lt;common/texture/texture-lod&gt;</span></span><br></pre></td></tr></table></figure><h3 id="常用内置变量"><a href="#常用内置变量" class="headerlink" title="常用内置变量"></a>常用内置变量</h3><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cc-global提供的变量</span></span><br><span class="line"><span class="keyword">uniform</span> CCGlobal &#123;</span><br><span class="line">  <span class="type">vec4</span> cc_time;              <span class="comment">// x=时间, y=deltaTime, z=frameCount</span></span><br><span class="line">  <span class="type">vec4</span> cc_screenSize;        <span class="comment">// x=width, y=height, z=1/width, w=1/height</span></span><br><span class="line">  <span class="type">vec4</span> cc_nativeSize;        <span class="comment">// 原生分辨率</span></span><br><span class="line">  <span class="type">mat4</span> cc_matView;           <span class="comment">// 视图矩阵</span></span><br><span class="line">  <span class="type">mat4</span> cc_matViewInv;        <span class="comment">// 视图逆矩阵</span></span><br><span class="line">  <span class="type">mat4</span> cc_matProj;           <span class="comment">// 投影矩阵</span></span><br><span class="line">  <span class="type">mat4</span> cc_matProjInv;        <span class="comment">// 投影逆矩阵</span></span><br><span class="line">  <span class="type">mat4</span> cc_matViewProj;       <span class="comment">// 视图投影矩阵</span></span><br><span class="line">  <span class="type">mat4</span> cc_matViewProjInv;    <span class="comment">// 视图投影逆矩阵</span></span><br><span class="line">  <span class="type">vec4</span> cc_cameraPos;         <span class="comment">// 相机位置</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// cc-local提供的变量</span></span><br><span class="line"><span class="keyword">uniform</span> CCLocal &#123;</span><br><span class="line">  <span class="type">mat4</span> cc_matWorld;          <span class="comment">// 模型矩阵</span></span><br><span class="line">  <span class="type">mat4</span> cc_matWorldIT;        <span class="comment">// 模型逆转置矩阵（法线变换用）</span></span><br><span class="line">  <span class="type">vec4</span> cc_lightingMap_uvParam; <span class="comment">// 光照贴图UV参数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="🎨-预处理器和宏"><a href="#🎨-预处理器和宏" class="headerlink" title="🎨 预处理器和宏"></a>🎨 预处理器和宏</h2><h3 id="条件编译"><a href="#条件编译" class="headerlink" title="条件编译"></a>条件编译</h3><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 功能开关</span></span><br><span class="line"><span class="meta">#if USE_ALBEDO_MAP</span></span><br><span class="line">  <span class="type">vec4</span> albedo = <span class="built_in">texture</span>(albedoMap, v_uv);</span><br><span class="line"><span class="meta">#else</span></span><br><span class="line">  <span class="type">vec4</span> albedo = baseColor;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 平台适配</span></span><br><span class="line"><span class="meta">#if CC_PLATFORM_ANDROID</span></span><br><span class="line">  <span class="keyword">precision</span> <span class="keyword">mediump</span> <span class="type">float</span>;</span><br><span class="line"><span class="meta">#else</span></span><br><span class="line">  <span class="keyword">precision</span> <span class="keyword">highp</span> <span class="type">float</span>;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 特性检测</span></span><br><span class="line"><span class="meta">#ifdef GL_EXT_shader_texture_lod</span></span><br><span class="line">  <span class="meta">#define TEXTURE_LOD(tex, uv, lod) textureLod(tex, uv, lod)</span></span><br><span class="line"><span class="meta">#else</span></span><br><span class="line">  <span class="meta">#define TEXTURE_LOD(tex, uv, lod) texture(tex, uv)</span></span><br><span class="line"><span class="meta">#endif</span></span><br></pre></td></tr></table></figure><h3 id="自定义宏"><a href="#自定义宏" class="headerlink" title="自定义宏"></a>自定义宏</h3><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数学常量</span></span><br><span class="line"><span class="meta">#define PI 3.14159265359</span></span><br><span class="line"><span class="meta">#define TWO_PI 6.28318530718</span></span><br><span class="line"><span class="meta">#define HALF_PI 1.57079632679</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 工具宏</span></span><br><span class="line"><span class="meta">#define saturate(x) clamp(x, 0.0, 1.0)</span></span><br><span class="line"><span class="meta">#define lerp(a, b, t) mix(a, b, t)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调试宏</span></span><br><span class="line"><span class="meta">#define DEBUG_OUTPUT(color) return vec4(color, 1.0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 条件宏</span></span><br><span class="line"><span class="meta">#define ENABLE_NORMAL_MAP 1</span></span><br><span class="line"><span class="meta">#if ENABLE_NORMAL_MAP</span></span><br><span class="line">  <span class="comment">// 法线贴图相关代码</span></span><br><span class="line"><span class="meta">#endif</span></span><br></pre></td></tr></table></figure><h2 id="🔗-属性传递机制"><a href="#🔗-属性传递机制" class="headerlink" title="🔗 属性传递机制"></a>🔗 属性传递机制</h2><h3 id="Properties到Uniform的映射"><a href="#Properties到Uniform的映射" class="headerlink" title="Properties到Uniform的映射"></a>Properties到Uniform的映射</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Properties定义</span></span><br><span class="line"><span class="attr">properties:</span></span><br><span class="line">  <span class="attr">mainTexture:</span> &#123; <span class="attr">value:</span> <span class="string">white</span> &#125;</span><br><span class="line">  <span class="attr">tintColor:</span> &#123; <span class="attr">value:</span> [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>] &#125;</span><br><span class="line">  <span class="attr">metallic:</span> &#123; <span class="attr">value:</span> <span class="number">0.0</span> &#125;</span><br><span class="line">  <span class="attr">roughness:</span> &#123; <span class="attr">value:</span> <span class="number">0.5</span> &#125;</span><br></pre></td></tr></table></figure><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自动生成的Uniform块</span></span><br><span class="line"><span class="keyword">uniform</span> MaterialUniforms &#123;</span><br><span class="line">  <span class="type">vec4</span> tintColor;</span><br><span class="line">  <span class="type">float</span> metallic;</span><br><span class="line">  <span class="type">float</span> roughness;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 纹理采样器（自动生成）</span></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> mainTexture;</span><br></pre></td></tr></table></figure><h3 id="动态属性"><a href="#动态属性" class="headerlink" title="动态属性"></a>动态属性</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 支持运行时修改的属性</span></span><br><span class="line"><span class="attr">dynamics:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">USE_VERTEX_COLOR</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">number</span></span><br><span class="line">    <span class="attr">value:</span> <span class="number">1</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">ALPHA_CUTOFF</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">number</span></span><br><span class="line">    <span class="attr">value:</span> <span class="number">0.5</span></span><br></pre></td></tr></table></figure><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在着色器中使用</span></span><br><span class="line"><span class="meta">#if USE_VERTEX_COLOR</span></span><br><span class="line">  finalColor *= v_color;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#if ALPHA_CUTOFF &gt; 0.0</span></span><br><span class="line">  <span class="keyword">if</span> (finalColor.a &lt; ALPHA_CUTOFF) &#123;</span><br><span class="line">    <span class="keyword">discard</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#endif</span></span><br></pre></td></tr></table></figure><h2 id="⚡-性能优化技巧"><a href="#⚡-性能优化技巧" class="headerlink" title="⚡ 性能优化技巧"></a>⚡ 性能优化技巧</h2><h3 id="1-精度控制"><a href="#1-精度控制" class="headerlink" title="1. 精度控制"></a>1. 精度控制</h3><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据需要选择精度</span></span><br><span class="line"><span class="keyword">precision</span> <span class="keyword">highp</span> <span class="type">float</span>;    <span class="comment">// 高精度（慢但准确）</span></span><br><span class="line"><span class="keyword">precision</span> <span class="keyword">mediump</span> <span class="type">float</span>;  <span class="comment">// 中精度（平衡）</span></span><br><span class="line"><span class="keyword">precision</span> <span class="keyword">lowp</span> <span class="type">float</span>;     <span class="comment">// 低精度（快但不准确）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 变量级精度控制</span></span><br><span class="line"><span class="keyword">lowp</span> <span class="type">vec4</span> color;          <span class="comment">// 颜色通常用低精度</span></span><br><span class="line"><span class="keyword">mediump</span> <span class="type">vec2</span> uv;          <span class="comment">// UV坐标用中精度</span></span><br><span class="line"><span class="keyword">highp</span> <span class="type">vec3</span> worldPos;      <span class="comment">// 世界位置需要高精度</span></span><br></pre></td></tr></table></figure><h3 id="2-减少计算复杂度"><a href="#2-减少计算复杂度" class="headerlink" title="2. 减少计算复杂度"></a>2. 减少计算复杂度</h3><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ❌ 避免：复杂的每像素计算</span></span><br><span class="line"><span class="type">float</span> complex = <span class="built_in">pow</span>(<span class="built_in">sin</span>(<span class="built_in">cos</span>(v_uv.x * <span class="number">100.0</span>)), <span class="number">3.0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ✅ 推荐：预计算或查找表</span></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> complexLUT;</span><br><span class="line"><span class="type">float</span> complex = <span class="built_in">texture</span>(complexLUT, v_uv).r;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ❌ 避免：分支语句</span></span><br><span class="line"><span class="keyword">if</span> (someCondition) &#123;</span><br><span class="line">  color = <span class="type">vec3</span>(<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  color = <span class="type">vec3</span>(<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ✅ 推荐：使用mix或step函数</span></span><br><span class="line">color = <span class="built_in">mix</span>(<span class="type">vec3</span>(<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>), <span class="type">vec3</span>(<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>), <span class="built_in">step</span>(<span class="number">0.5</span>, someValue));</span><br></pre></td></tr></table></figure><h3 id="3-纹理采样优化"><a href="#3-纹理采样优化" class="headerlink" title="3. 纹理采样优化"></a>3. 纹理采样优化</h3><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ❌ 避免：多次采样同一纹理</span></span><br><span class="line"><span class="type">vec4</span> sample1 = <span class="built_in">texture</span>(mainTexture, v_uv);</span><br><span class="line"><span class="type">vec4</span> sample2 = <span class="built_in">texture</span>(mainTexture, v_uv + <span class="keyword">offset</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ✅ 推荐：批量采样</span></span><br><span class="line"><span class="type">vec4</span> samples = <span class="built_in">textureGather</span>(mainTexture, v_uv);</span><br></pre></td></tr></table></figure><h2 id="🛠️-调试技巧"><a href="#🛠️-调试技巧" class="headerlink" title="🛠️ 调试技巧"></a>🛠️ 调试技巧</h2><h3 id="可视化调试"><a href="#可视化调试" class="headerlink" title="可视化调试"></a>可视化调试</h3><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调试UV坐标</span></span><br><span class="line"><span class="meta">#define DEBUG_UV</span></span><br><span class="line"><span class="meta">#ifdef DEBUG_UV</span></span><br><span class="line">  <span class="keyword">return</span> <span class="type">vec4</span>(v_uv, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调试法线</span></span><br><span class="line"><span class="meta">#define DEBUG_NORMAL</span></span><br><span class="line"><span class="meta">#ifdef DEBUG_NORMAL</span></span><br><span class="line">  <span class="keyword">return</span> <span class="type">vec4</span>(v_worldNormal * <span class="number">0.5</span> + <span class="number">0.5</span>, <span class="number">1.0</span>);</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调试深度</span></span><br><span class="line"><span class="meta">#define DEBUG_DEPTH</span></span><br><span class="line"><span class="meta">#ifdef DEBUG_DEPTH</span></span><br><span class="line">  <span class="type">float</span> depth = <span class="built_in">gl_FragCoord</span>.z;</span><br><span class="line">  <span class="keyword">return</span> <span class="type">vec4</span>(<span class="type">vec3</span>(depth), <span class="number">1.0</span>);</span><br><span class="line"><span class="meta">#endif</span></span><br></pre></td></tr></table></figure><h3 id="分步验证"><a href="#分步验证" class="headerlink" title="分步验证"></a>分步验证</h3><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分步骤验证计算结果</span></span><br><span class="line"><span class="type">vec4</span> frag() &#123;</span><br><span class="line">  <span class="type">vec4</span> texColor = <span class="built_in">texture</span>(mainTexture, v_uv);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 第一步：只显示纹理</span></span><br><span class="line">  <span class="meta">#if DEBUG_STEP == 1</span></span><br><span class="line">    <span class="keyword">return</span> texColor;</span><br><span class="line">  <span class="meta">#endif</span></span><br><span class="line">  </span><br><span class="line">  <span class="type">vec4</span> tinted = texColor * tintColor;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 第二步：显示着色后的结果</span></span><br><span class="line">  <span class="meta">#if DEBUG_STEP == 2</span></span><br><span class="line">    <span class="keyword">return</span> tinted;</span><br><span class="line">  <span class="meta">#endif</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 完整效果</span></span><br><span class="line">  <span class="keyword">return</span> tinted * v_color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="📚-本章总结"><a href="#📚-本章总结" class="headerlink" title="📚 本章总结"></a>📚 本章总结</h2><p>通过本章学习，我们全面掌握了Cocos Shader语法：</p><ul><li>✅ 理解了Cocos Shader的整体结构和语法特点</li><li>✅ 掌握了CCEffect配置的详细语法</li><li>✅ 学会了编写CCProgram着色器程序</li><li>✅ 了解了内置函数和变量的使用方法</li><li>✅ 掌握了性能优化和调试技巧</li></ul><h2 id="🚀-下一步"><a href="#🚀-下一步" class="headerlink" title="🚀 下一步"></a>🚀 下一步</h2><p>现在你已经掌握了Cocos Shader的语法基础，接下来我们将学习内置着色器：</p><p>👉 <strong><a href="!--swig%EF%BF%BC19--">第4章：PBR着色器基础教程</a></strong></p><h2 id="💡-实践练习"><a href="#💡-实践练习" class="headerlink" title="💡 实践练习"></a>💡 实践练习</h2><ol><li><strong>语法练习</strong>: 创建一个简单的颜色变化着色器</li><li><strong>配置练习</strong>: 尝试不同的渲染状态配置</li><li><strong>调试练习</strong>: 使用调试技巧验证计算结果</li></ol><hr><blockquote><p><strong>重要提示</strong>: 熟练掌握Cocos Shader语法是高效开发的基础，建议多动手实践。 </p></blockquote>]]></content>
      
      
      <categories>
          
          <category> CocosShader </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CocosShader </tag>
            
            <tag> Syntax </tag>
            
            <tag> YAML </tag>
            
            <tag> GLSL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第9章：2D渐变精灵着色器实战</title>
      <link href="//CocosShader/2d-gradient-sprite-shader/"/>
      <url>//CocosShader/2d-gradient-sprite-shader/</url>
      
        <content type="html"><![CDATA[<h1 id="第9章：2D渐变精灵着色器实战"><a href="#第9章：2D渐变精灵着色器实战" class="headerlink" title="第9章：2D渐变精灵着色器实战"></a>第9章：2D渐变精灵着色器实战</h1><p>在2D游戏开发中，渐变效果是创造视觉冲击力的重要手段。本章将详细介绍如何在Cocos Creator中实现各种2D精灵渐变效果，包括线性渐变、径向渐变和动态渐变。</p><span id="more"></span><h2 id="🎯-学习目标"><a href="#🎯-学习目标" class="headerlink" title="🎯 学习目标"></a>🎯 学习目标</h2><p>通过本章学习，你将掌握：</p><ul><li>2D渐变的数学原理和实现方法</li><li>在Cocos Creator中创建渐变精灵着色器</li><li>各种渐变类型的实现（线性、径向、角度渐变）</li><li>动态渐变和动画效果的制作</li></ul><h2 id="🌈-渐变效果概览"><a href="#🌈-渐变效果概览" class="headerlink" title="🌈 渐变效果概览"></a>🌈 渐变效果概览</h2><h3 id="渐变的类型"><a href="#渐变的类型" class="headerlink" title="渐变的类型"></a>渐变的类型</h3><p>2D渐变主要包含以下几种类型：</p><ol><li><p><strong>线性渐变（Linear Gradient）</strong></p><ul><li>沿直线方向的颜色过渡</li><li>可控制方向和位置</li></ul></li><li><p><strong>径向渐变（Radial Gradient）</strong></p><ul><li>从中心点向外扩散的圆形渐变</li><li>可控制中心点和半径</li></ul></li><li><p><strong>角度渐变（Angular Gradient）</strong></p><ul><li>围绕中心点的旋转渐变</li><li>创造彩虹或光谱效果</li></ul></li><li><p><strong>动态渐变（Animated Gradient）</strong></p><ul><li>随时间变化的渐变效果</li><li>适用于能量条、充能效果等</li></ul></li></ol><h2 id="📐-渐变数学原理"><a href="#📐-渐变数学原理" class="headerlink" title="📐 渐变数学原理"></a>📐 渐变数学原理</h2><h3 id="线性渐变计算"><a href="#线性渐变计算" class="headerlink" title="线性渐变计算"></a>线性渐变计算</h3><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线性渐变的基本计算</span></span><br><span class="line"><span class="type">float</span> linearGradient(<span class="type">vec2</span> uv, <span class="type">vec2</span> direction, <span class="type">vec2</span> <span class="keyword">offset</span>) &#123;</span><br><span class="line">    <span class="comment">// 标准化方向向量</span></span><br><span class="line">    <span class="type">vec2</span> normalizedDir = <span class="built_in">normalize</span>(direction);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算UV在渐变方向上的投影</span></span><br><span class="line">    <span class="type">float</span> projection = <span class="built_in">dot</span>(uv - <span class="keyword">offset</span>, normalizedDir);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将投影映射到[0,1]范围</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">clamp</span>(projection, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="径向渐变计算"><a href="#径向渐变计算" class="headerlink" title="径向渐变计算"></a>径向渐变计算</h3><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 径向渐变的基本计算</span></span><br><span class="line"><span class="type">float</span> radialGradient(<span class="type">vec2</span> uv, <span class="type">vec2</span> center, <span class="type">float</span> radius) &#123;</span><br><span class="line">    <span class="comment">// 计算距离中心的距离</span></span><br><span class="line">    <span class="type">float</span> <span class="built_in">distance</span> = <span class="built_in">length</span>(uv - center);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 标准化到[0,1]范围</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">clamp</span>(<span class="number">1.0</span> - <span class="built_in">distance</span> / radius, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="角度渐变计算"><a href="#角度渐变计算" class="headerlink" title="角度渐变计算"></a>角度渐变计算</h3><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 角度渐变的基本计算</span></span><br><span class="line"><span class="type">float</span> angularGradient(<span class="type">vec2</span> uv, <span class="type">vec2</span> center, <span class="type">float</span> rotation) &#123;</span><br><span class="line">    <span class="comment">// 计算相对于中心的角度</span></span><br><span class="line">    <span class="type">vec2</span> dir = uv - center;</span><br><span class="line">    <span class="type">float</span> angle = <span class="built_in">atan</span>(dir.y, dir.x);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加旋转偏移</span></span><br><span class="line">    angle += rotation;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 标准化到[0,1]范围</span></span><br><span class="line">    <span class="keyword">return</span> (angle + PI) / (<span class="number">2.0</span> * PI);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="🛠️-基础线性渐变着色器"><a href="#🛠️-基础线性渐变着色器" class="headerlink" title="🛠️ 基础线性渐变着色器"></a>🛠️ 基础线性渐变着色器</h2><h3 id="简单线性渐变实现"><a href="#简单线性渐变实现" class="headerlink" title="简单线性渐变实现"></a>简单线性渐变实现</h3><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">CCEffect:</span><br><span class="line">  techniques:</span><br><span class="line">    - name: opaque</span><br><span class="line">      passes:</span><br><span class="line">        - vert: sprite-vs</span><br><span class="line">          frag: linear-gradient-fs</span><br><span class="line">          properties:</span><br><span class="line">            mainTexture:    &#123; value: white &#125;</span><br><span class="line">            startColor:     &#123; value: [<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>], editor: &#123; type: color &#125; &#125;</span><br><span class="line">            endColor:       &#123; value: [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>], editor: &#123; type: color &#125; &#125;</span><br><span class="line">            gradientDir:    &#123; value: [<span class="number">1</span>, <span class="number">0</span>], editor: &#123; tooltip: &quot;渐变方向&quot; &#125; &#125;</span><br><span class="line">            gradientOffset: &#123; value: [<span class="number">0</span>, <span class="number">0</span>], editor: &#123; tooltip: &quot;渐变偏移&quot; &#125; &#125;</span><br><span class="line"></span><br><span class="line">CCProgram sprite-vs %&#123;</span><br><span class="line">  <span class="keyword">precision</span> <span class="keyword">highp</span> <span class="type">float</span>;</span><br><span class="line">  <span class="meta">#include &lt;builtin/uniforms/cc-global&gt;</span></span><br><span class="line">  <span class="meta">#include &lt;builtin/uniforms/cc-local&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">in</span> <span class="type">vec3</span> a_position;</span><br><span class="line">  <span class="keyword">in</span> <span class="type">vec2</span> a_texCoord;</span><br><span class="line">  <span class="keyword">in</span> <span class="type">vec4</span> a_color;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">out</span> <span class="type">vec2</span> v_uv;</span><br><span class="line">  <span class="keyword">out</span> <span class="type">vec4</span> v_color;</span><br><span class="line">  </span><br><span class="line">  <span class="type">vec4</span> vert() &#123;</span><br><span class="line">    <span class="type">vec4</span> pos = <span class="type">vec4</span>(a_position, <span class="number">1</span>);</span><br><span class="line">    pos = cc_matWorld * pos;</span><br><span class="line">    pos = cc_matViewProj * pos;</span><br><span class="line">    </span><br><span class="line">    v_uv = a_texCoord;</span><br><span class="line">    v_color = a_color;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> pos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;%</span><br><span class="line"></span><br><span class="line">CCProgram linear-gradient-fs %&#123;</span><br><span class="line">  <span class="keyword">precision</span> <span class="keyword">highp</span> <span class="type">float</span>;</span><br><span class="line">  <span class="meta">#include &lt;builtin/uniforms/cc-global&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">in</span> <span class="type">vec2</span> v_uv;</span><br><span class="line">  <span class="keyword">in</span> <span class="type">vec4</span> v_color;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">uniform</span> <span class="type">sampler2D</span> mainTexture;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">uniform</span> GradientUniforms &#123;</span><br><span class="line">    <span class="type">vec4</span> startColor;</span><br><span class="line">    <span class="type">vec4</span> endColor;</span><br><span class="line">    <span class="type">vec2</span> gradientDir;</span><br><span class="line">    <span class="type">vec2</span> gradientOffset;</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="type">vec4</span> frag() &#123;</span><br><span class="line">    <span class="comment">// 采样原始纹理</span></span><br><span class="line">    <span class="type">vec4</span> texColor = <span class="built_in">texture</span>(mainTexture, v_uv);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算渐变因子</span></span><br><span class="line">    <span class="type">vec2</span> normalizedDir = <span class="built_in">normalize</span>(gradientDir);</span><br><span class="line">    <span class="type">float</span> gradientFactor = <span class="built_in">dot</span>(v_uv - gradientOffset, normalizedDir);</span><br><span class="line">    gradientFactor = <span class="built_in">clamp</span>(gradientFactor, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在两种颜色之间插值</span></span><br><span class="line">    <span class="type">vec4</span> gradientColor = <span class="built_in">mix</span>(startColor, endColor, gradientFactor);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 与原始纹理混合</span></span><br><span class="line">    <span class="type">vec4</span> finalColor = texColor * gradientColor * v_color;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> finalColor;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;%</span><br></pre></td></tr></table></figure><h3 id="多色彩线性渐变"><a href="#多色彩线性渐变" class="headerlink" title="多色彩线性渐变"></a>多色彩线性渐变</h3><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">CCProgram multi-color-gradient-fs %&#123;</span><br><span class="line">  <span class="keyword">precision</span> <span class="keyword">highp</span> <span class="type">float</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">uniform</span> MultiGradientUniforms &#123;</span><br><span class="line">    <span class="type">vec4</span> color1;</span><br><span class="line">    <span class="type">vec4</span> color2; </span><br><span class="line">    <span class="type">vec4</span> color3;</span><br><span class="line">    <span class="type">vec4</span> color4;</span><br><span class="line">    <span class="type">vec2</span> gradientDir;</span><br><span class="line">    <span class="type">float</span> segments; <span class="comment">// 分段数量</span></span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="type">vec4</span> multiColorGradient(<span class="type">float</span> factor) &#123;</span><br><span class="line">    <span class="comment">// 将[0,1]分成多个段</span></span><br><span class="line">    <span class="type">float</span> segmentSize = <span class="number">1.0</span> / segments;</span><br><span class="line">    <span class="type">float</span> segment = <span class="built_in">floor</span>(factor / segmentSize);</span><br><span class="line">    <span class="type">float</span> localFactor = (factor - segment * segmentSize) / segmentSize;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据段数选择颜色</span></span><br><span class="line">    <span class="keyword">if</span> (segment &lt; <span class="number">1.0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">mix</span>(color1, color2, localFactor);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (segment &lt; <span class="number">2.0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">mix</span>(color2, color3, localFactor);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">mix</span>(color3, color4, localFactor);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="type">vec4</span> frag() &#123;</span><br><span class="line">    <span class="type">vec4</span> texColor = <span class="built_in">texture</span>(mainTexture, v_uv);</span><br><span class="line">    </span><br><span class="line">    <span class="type">vec2</span> normalizedDir = <span class="built_in">normalize</span>(gradientDir);</span><br><span class="line">    <span class="type">float</span> gradientFactor = <span class="built_in">dot</span>(v_uv, normalizedDir);</span><br><span class="line">    gradientFactor = <span class="built_in">clamp</span>(gradientFactor, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="type">vec4</span> gradientColor = multiColorGradient(gradientFactor);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> texColor * gradientColor * v_color;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;%</span><br></pre></td></tr></table></figure><h2 id="🌀-径向渐变着色器"><a href="#🌀-径向渐变着色器" class="headerlink" title="🌀 径向渐变着色器"></a>🌀 径向渐变着色器</h2><h3 id="基础径向渐变"><a href="#基础径向渐变" class="headerlink" title="基础径向渐变"></a>基础径向渐变</h3><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">CCProgram radial-gradient-fs %&#123;</span><br><span class="line">  <span class="keyword">precision</span> <span class="keyword">highp</span> <span class="type">float</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">uniform</span> RadialGradientUniforms &#123;</span><br><span class="line">    <span class="type">vec4</span> centerColor;</span><br><span class="line">    <span class="type">vec4</span> edgeColor;</span><br><span class="line">    <span class="type">vec2</span> center;        <span class="comment">// 渐变中心 [0-1]</span></span><br><span class="line">    <span class="type">float</span> radius;       <span class="comment">// 渐变半径 [0-1]</span></span><br><span class="line">    <span class="type">float</span> smoothness;   <span class="comment">// 边缘柔和度</span></span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="type">vec4</span> frag() &#123;</span><br><span class="line">    <span class="type">vec4</span> texColor = <span class="built_in">texture</span>(mainTexture, v_uv);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算到中心的距离</span></span><br><span class="line">    <span class="type">float</span> <span class="built_in">distance</span> = <span class="built_in">length</span>(v_uv - center);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算渐变因子</span></span><br><span class="line">    <span class="type">float</span> gradientFactor = <span class="built_in">distance</span> / radius;</span><br><span class="line">    gradientFactor = <span class="built_in">clamp</span>(gradientFactor, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 应用平滑过渡</span></span><br><span class="line">    gradientFactor = <span class="built_in">smoothstep</span>(<span class="number">0.0</span>, smoothness, gradientFactor);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 颜色插值</span></span><br><span class="line">    <span class="type">vec4</span> gradientColor = <span class="built_in">mix</span>(centerColor, edgeColor, gradientFactor);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> texColor * gradientColor * v_color;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;%</span><br></pre></td></tr></table></figure><h3 id="椭圆径向渐变"><a href="#椭圆径向渐变" class="headerlink" title="椭圆径向渐变"></a>椭圆径向渐变</h3><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">CCProgram elliptical-gradient-fs %&#123;</span><br><span class="line">  <span class="keyword">uniform</span> EllipticalUniforms &#123;</span><br><span class="line">    <span class="type">vec4</span> centerColor;</span><br><span class="line">    <span class="type">vec4</span> edgeColor;</span><br><span class="line">    <span class="type">vec2</span> center;</span><br><span class="line">    <span class="type">vec2</span> radius;        <span class="comment">// x和y方向的半径</span></span><br><span class="line">    <span class="type">float</span> rotation;     <span class="comment">// 旋转角度</span></span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 旋转矩阵</span></span><br><span class="line">  <span class="type">mat2</span> rotate2D(<span class="type">float</span> angle) &#123;</span><br><span class="line">    <span class="type">float</span> s = <span class="built_in">sin</span>(angle);</span><br><span class="line">    <span class="type">float</span> c = <span class="built_in">cos</span>(angle);</span><br><span class="line">    <span class="keyword">return</span> <span class="type">mat2</span>(c, -s, s, c);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="type">vec4</span> frag() &#123;</span><br><span class="line">    <span class="type">vec4</span> texColor = <span class="built_in">texture</span>(mainTexture, v_uv);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算相对位置</span></span><br><span class="line">    <span class="type">vec2</span> pos = v_uv - center;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 应用旋转</span></span><br><span class="line">    pos = rotate2D(rotation) * pos;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 椭圆距离计算</span></span><br><span class="line">    <span class="type">vec2</span> normalizedPos = pos / radius;</span><br><span class="line">    <span class="type">float</span> <span class="built_in">distance</span> = <span class="built_in">length</span>(normalizedPos);</span><br><span class="line">    </span><br><span class="line">    <span class="type">float</span> gradientFactor = <span class="built_in">clamp</span>(<span class="built_in">distance</span>, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">    <span class="type">vec4</span> gradientColor = <span class="built_in">mix</span>(centerColor, edgeColor, gradientFactor);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> texColor * gradientColor * v_color;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;%</span><br></pre></td></tr></table></figure><h2 id="🎨-角度渐变着色器"><a href="#🎨-角度渐变着色器" class="headerlink" title="🎨 角度渐变着色器"></a>🎨 角度渐变着色器</h2><h3 id="彩虹色环渐变"><a href="#彩虹色环渐变" class="headerlink" title="彩虹色环渐变"></a>彩虹色环渐变</h3><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">CCProgram angular-gradient-fs %&#123;</span><br><span class="line">  <span class="keyword">precision</span> <span class="keyword">highp</span> <span class="type">float</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">uniform</span> AngularUniforms &#123;</span><br><span class="line">    <span class="type">vec2</span> center;</span><br><span class="line">    <span class="type">float</span> rotation;</span><br><span class="line">    <span class="type">float</span> brightness;</span><br><span class="line">    <span class="type">float</span> saturation;</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// HSV到RGB转换</span></span><br><span class="line">  <span class="type">vec3</span> hsv2rgb(<span class="type">vec3</span> c) &#123;</span><br><span class="line">    <span class="type">vec4</span> K = <span class="type">vec4</span>(<span class="number">1.0</span>, <span class="number">2.0</span> / <span class="number">3.0</span>, <span class="number">1.0</span> / <span class="number">3.0</span>, <span class="number">3.0</span>);</span><br><span class="line">    <span class="type">vec3</span> p = <span class="built_in">abs</span>(<span class="built_in">fract</span>(c.xxx + K.xyz) * <span class="number">6.0</span> - K.www);</span><br><span class="line">    <span class="keyword">return</span> c.z * <span class="built_in">mix</span>(K.xxx, <span class="built_in">clamp</span>(p - K.xxx, <span class="number">0.0</span>, <span class="number">1.0</span>), c.y);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="type">vec4</span> frag() &#123;</span><br><span class="line">    <span class="type">vec4</span> texColor = <span class="built_in">texture</span>(mainTexture, v_uv);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算角度</span></span><br><span class="line">    <span class="type">vec2</span> dir = v_uv - center;</span><br><span class="line">    <span class="type">float</span> angle = <span class="built_in">atan</span>(dir.y, dir.x);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加旋转并标准化到[0,1]</span></span><br><span class="line">    angle += rotation;</span><br><span class="line">    <span class="type">float</span> hue = (angle + PI) / (<span class="number">2.0</span> * PI);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建HSV颜色</span></span><br><span class="line">    <span class="type">vec3</span> hsv = <span class="type">vec3</span>(hue, saturation, brightness);</span><br><span class="line">    <span class="type">vec3</span> gradientColor = hsv2rgb(hsv);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> texColor * <span class="type">vec4</span>(gradientColor, <span class="number">1.0</span>) * v_color;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;%</span><br></pre></td></tr></table></figure><h3 id="双色角度渐变"><a href="#双色角度渐变" class="headerlink" title="双色角度渐变"></a>双色角度渐变</h3><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">CCProgram dual-angular-gradient-fs %&#123;</span><br><span class="line">  <span class="keyword">uniform</span> DualAngularUniforms &#123;</span><br><span class="line">    <span class="type">vec4</span> color1;</span><br><span class="line">    <span class="type">vec4</span> color2;</span><br><span class="line">    <span class="type">vec2</span> center;</span><br><span class="line">    <span class="type">float</span> rotation;</span><br><span class="line">    <span class="type">float</span> sharpness;  <span class="comment">// 过渡锐利度</span></span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="type">vec4</span> frag() &#123;</span><br><span class="line">    <span class="type">vec4</span> texColor = <span class="built_in">texture</span>(mainTexture, v_uv);</span><br><span class="line">    </span><br><span class="line">    <span class="type">vec2</span> dir = v_uv - center;</span><br><span class="line">    <span class="type">float</span> angle = <span class="built_in">atan</span>(dir.y, dir.x) + rotation;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将角度映射到[0,1]，然后使用sin函数创建周期性渐变</span></span><br><span class="line">    <span class="type">float</span> factor = <span class="built_in">sin</span>(angle) * <span class="number">0.5</span> + <span class="number">0.5</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 应用锐利度</span></span><br><span class="line">    factor = <span class="built_in">pow</span>(factor, sharpness);</span><br><span class="line">    </span><br><span class="line">    <span class="type">vec4</span> gradientColor = <span class="built_in">mix</span>(color1, color2, factor);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> texColor * gradientColor * v_color;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;%</span><br></pre></td></tr></table></figure><h2 id="⚡-动态渐变效果"><a href="#⚡-动态渐变效果" class="headerlink" title="⚡ 动态渐变效果"></a>⚡ 动态渐变效果</h2><h3 id="时间驱动的流动渐变"><a href="#时间驱动的流动渐变" class="headerlink" title="时间驱动的流动渐变"></a>时间驱动的流动渐变</h3><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">CCProgram flowing-gradient-fs %&#123;</span><br><span class="line">  <span class="keyword">precision</span> <span class="keyword">highp</span> <span class="type">float</span>;</span><br><span class="line">  <span class="meta">#include &lt;builtin/uniforms/cc-global&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">uniform</span> FlowingUniforms &#123;</span><br><span class="line">    <span class="type">vec4</span> color1;</span><br><span class="line">    <span class="type">vec4</span> color2;</span><br><span class="line">    <span class="type">vec2</span> flowDirection;</span><br><span class="line">    <span class="type">float</span> flowSpeed;</span><br><span class="line">    <span class="type">float</span> waveLength;</span><br><span class="line">    <span class="type">float</span> intensity;</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="type">vec4</span> frag() &#123;</span><br><span class="line">    <span class="type">vec4</span> texColor = <span class="built_in">texture</span>(mainTexture, v_uv);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 基于时间和位置的流动计算</span></span><br><span class="line">    <span class="type">vec2</span> flow = flowDirection * cc_time.x * flowSpeed;</span><br><span class="line">    <span class="type">float</span> wave = <span class="built_in">sin</span>((<span class="built_in">dot</span>(v_uv, <span class="built_in">normalize</span>(flowDirection)) + flow.x) * waveLength);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建动态渐变因子</span></span><br><span class="line">    <span class="type">float</span> factor = (wave + <span class="number">1.0</span>) * <span class="number">0.5</span>;</span><br><span class="line">    factor = <span class="built_in">mix</span>(<span class="number">0.5</span>, factor, intensity);</span><br><span class="line">    </span><br><span class="line">    <span class="type">vec4</span> gradientColor = <span class="built_in">mix</span>(color1, color2, factor);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> texColor * gradientColor * v_color;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;%</span><br></pre></td></tr></table></figure><h3 id="脉冲渐变效果"><a href="#脉冲渐变效果" class="headerlink" title="脉冲渐变效果"></a>脉冲渐变效果</h3><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">CCProgram pulse-gradient-fs %&#123;</span><br><span class="line">  <span class="keyword">uniform</span> PulseUniforms &#123;</span><br><span class="line">    <span class="type">vec4</span> baseColor;</span><br><span class="line">    <span class="type">vec4</span> pulseColor;</span><br><span class="line">    <span class="type">vec2</span> center;</span><br><span class="line">    <span class="type">float</span> pulseSpeed;</span><br><span class="line">    <span class="type">float</span> pulseRadius;</span><br><span class="line">    <span class="type">float</span> pulseWidth;</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="type">vec4</span> frag() &#123;</span><br><span class="line">    <span class="type">vec4</span> texColor = <span class="built_in">texture</span>(mainTexture, v_uv);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算距离中心的距离</span></span><br><span class="line">    <span class="type">float</span> <span class="built_in">distance</span> = <span class="built_in">length</span>(v_uv - center);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建脉冲波</span></span><br><span class="line">    <span class="type">float</span> pulse = <span class="built_in">sin</span>(cc_time.x * pulseSpeed - <span class="built_in">distance</span> * pulseRadius);</span><br><span class="line">    pulse = <span class="built_in">smoothstep</span>(-pulseWidth, pulseWidth, pulse);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 混合颜色</span></span><br><span class="line">    <span class="type">vec4</span> gradientColor = <span class="built_in">mix</span>(baseColor, pulseColor, pulse);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> texColor * gradientColor * v_color;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;%</span><br></pre></td></tr></table></figure><h2 id="🎮-实用应用场景"><a href="#🎮-实用应用场景" class="headerlink" title="🎮 实用应用场景"></a>🎮 实用应用场景</h2><h3 id="1-能量条渐变"><a href="#1-能量条渐变" class="headerlink" title="1. 能量条渐变"></a>1. 能量条渐变</h3><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">CCProgram energy-bar-fs %&#123;</span><br><span class="line">  <span class="keyword">uniform</span> EnergyBarUniforms &#123;</span><br><span class="line">    <span class="type">vec4</span> emptyColor;    <span class="comment">// 空槽颜色</span></span><br><span class="line">    <span class="type">vec4</span> fullColor;     <span class="comment">// 满槽颜色</span></span><br><span class="line">    <span class="type">vec4</span> criticalColor; <span class="comment">// 危险颜色</span></span><br><span class="line">    <span class="type">float</span> fillAmount;   <span class="comment">// 填充量 [0-1]</span></span><br><span class="line">    <span class="type">float</span> criticalThreshold; <span class="comment">// 危险阈值</span></span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="type">vec4</span> frag() &#123;</span><br><span class="line">    <span class="type">vec4</span> texColor = <span class="built_in">texture</span>(mainTexture, v_uv);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断是否在填充区域内</span></span><br><span class="line">    <span class="type">bool</span> isFilled = v_uv.x &lt;= fillAmount;</span><br><span class="line">    </span><br><span class="line">    <span class="type">vec4</span> gradientColor;</span><br><span class="line">    <span class="keyword">if</span> (isFilled) &#123;</span><br><span class="line">      <span class="comment">// 在填充区域内</span></span><br><span class="line">      <span class="keyword">if</span> (fillAmount &lt;= criticalThreshold) &#123;</span><br><span class="line">        <span class="comment">// 危险状态 - 红色闪烁</span></span><br><span class="line">        <span class="type">float</span> flash = <span class="built_in">sin</span>(cc_time.x * <span class="number">10.0</span>) * <span class="number">0.5</span> + <span class="number">0.5</span>;</span><br><span class="line">        gradientColor = <span class="built_in">mix</span>(criticalColor, fullColor, flash);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 正常状态 - 渐变填充</span></span><br><span class="line">        <span class="type">float</span> localFactor = v_uv.x / fillAmount;</span><br><span class="line">        gradientColor = <span class="built_in">mix</span>(fullColor, emptyColor, localFactor * <span class="number">0.3</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 在空槽区域</span></span><br><span class="line">      gradientColor = emptyColor;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> texColor * gradientColor * v_color;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;%</span><br></pre></td></tr></table></figure><h3 id="2-按钮光晕效果"><a href="#2-按钮光晕效果" class="headerlink" title="2. 按钮光晕效果"></a>2. 按钮光晕效果</h3><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">CCProgram button-glow-fs %&#123;</span><br><span class="line">  <span class="keyword">uniform</span> GlowUniforms &#123;</span><br><span class="line">    <span class="type">vec4</span> baseColor;</span><br><span class="line">    <span class="type">vec4</span> glowColor;</span><br><span class="line">    <span class="type">float</span> glowIntensity;</span><br><span class="line">    <span class="type">float</span> glowRadius;</span><br><span class="line">    <span class="type">vec2</span> glowCenter;</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="type">vec4</span> frag() &#123;</span><br><span class="line">    <span class="type">vec4</span> texColor = <span class="built_in">texture</span>(mainTexture, v_uv);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算到光晕中心的距离</span></span><br><span class="line">    <span class="type">float</span> <span class="built_in">distance</span> = <span class="built_in">length</span>(v_uv - glowCenter);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建光晕渐变</span></span><br><span class="line">    <span class="type">float</span> glow = <span class="built_in">exp</span>(-<span class="built_in">distance</span> * glowRadius) * glowIntensity;</span><br><span class="line">    glow = <span class="built_in">clamp</span>(glow, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 混合基础颜色和光晕</span></span><br><span class="line">    <span class="type">vec4</span> finalColor = <span class="built_in">mix</span>(baseColor, glowColor, glow);</span><br><span class="line">    finalColor += glowColor * glow * <span class="number">0.5</span>; <span class="comment">// 添加额外光晕</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> texColor * finalColor * v_color;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;%</span><br></pre></td></tr></table></figure><h2 id="🔧-性能优化技巧"><a href="#🔧-性能优化技巧" class="headerlink" title="🔧 性能优化技巧"></a>🔧 性能优化技巧</h2><h3 id="1-预计算优化"><a href="#1-预计算优化" class="headerlink" title="1. 预计算优化"></a>1. 预计算优化</h3><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将复杂计算移到顶点着色器</span></span><br><span class="line"><span class="comment">// 顶点着色器中：</span></span><br><span class="line"><span class="keyword">out</span> <span class="type">float</span> v_gradientFactor;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> vert() &#123;</span><br><span class="line">  <span class="comment">// 在顶点着色器中计算渐变因子</span></span><br><span class="line">  <span class="type">vec2</span> normalizedDir = <span class="built_in">normalize</span>(gradientDir);</span><br><span class="line">  v_gradientFactor = <span class="built_in">dot</span>(a_texCoord - gradientOffset, normalizedDir);</span><br><span class="line">  <span class="comment">// ... 其他计算</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 片元着色器中：</span></span><br><span class="line"><span class="type">vec4</span> frag() &#123;</span><br><span class="line">  <span class="type">float</span> factor = <span class="built_in">clamp</span>(v_gradientFactor, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">  <span class="type">vec4</span> gradientColor = <span class="built_in">mix</span>(startColor, endColor, factor);</span><br><span class="line">  <span class="comment">// ... 其他计算</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-查找表优化"><a href="#2-查找表优化" class="headerlink" title="2. 查找表优化"></a>2. 查找表优化</h3><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用1D纹理作为渐变查找表</span></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> gradientLUT;</span><br><span class="line"></span><br><span class="line"><span class="type">vec4</span> frag() &#123;</span><br><span class="line">  <span class="type">vec4</span> texColor = <span class="built_in">texture</span>(mainTexture, v_uv);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 计算渐变因子</span></span><br><span class="line">  <span class="type">float</span> factor = computeGradientFactor(v_uv);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 使用查找表获取颜色</span></span><br><span class="line">  <span class="type">vec4</span> gradientColor = <span class="built_in">texture</span>(gradientLUT, <span class="type">vec2</span>(factor, <span class="number">0.5</span>));</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> texColor * gradientColor * v_color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="📚-本章总结"><a href="#📚-本章总结" class="headerlink" title="📚 本章总结"></a>📚 本章总结</h2><p>通过本章学习，我们掌握了2D渐变着色器的完整技术：</p><ul><li>✅ 理解了各种渐变类型的数学原理</li><li>✅ 实现了线性、径向、角度渐变效果</li><li>✅ 创建了动态和动画渐变效果</li><li>✅ 学会了实际游戏场景的应用方法</li><li>✅ 掌握了性能优化技巧</li></ul><h2 id="🚀-下一步"><a href="#🚀-下一步" class="headerlink" title="🚀 下一步"></a>🚀 下一步</h2><p>现在你已经掌握了2D渐变着色器，接下来我们将学习更多2D特效：</p><p>👉 <strong><a href="!--swig%EF%BF%BC15--">返回学习指南</a></strong></p><h2 id="💡-实践练习"><a href="#💡-实践练习" class="headerlink" title="💡 实践练习"></a>💡 实践练习</h2><ol><li><strong>基础练习</strong>: 创建一个可调节的多色线性渐变</li><li><strong>进阶练习</strong>: 实现一个动态彩虹色环效果</li><li><strong>应用练习</strong>: 制作一个带渐变动画的UI按钮</li></ol><hr><blockquote><p><strong>技巧提示</strong>: 渐变效果是2D游戏中最常用的视觉增强手段，掌握好基础原理可以创造出无限的视觉可能。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> CocosShader </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CocosShader </tag>
            
            <tag> 2D Graphics </tag>
            
            <tag> Sprite Effects </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>色阶</title>
      <link href="/2024/09/24/GameArt/GameArt101/"/>
      <url>/2024/09/24/GameArt/GameArt101/</url>
      
        <content type="html"><![CDATA[<p><strong>色阶（Color Gradation）是指颜色在明度、饱和度或色调上的渐变效果。</strong></p><h3 id="美术和设计领域"><a href="#美术和设计领域" class="headerlink" title="美术和设计领域"></a>美术和设计领域</h3><p>在美术和设计领域，色阶的概念非常重要，它可以帮助艺术家和设计师创造出丰富的视觉效果和层次感。以下是色阶的一些基本概念：</p><ol><li><p><strong>明度色阶</strong>：指的是颜色从最亮到最暗的渐变，也就是从白色到黑色的渐变。在明度色阶中，颜色的明度逐渐变化，但颜色的色调和饱和度保持不变。</p></li><li><p><strong>饱和度色阶</strong>：指的是颜色从最饱和到最不饱和的渐变，也就是从纯色到灰色的渐变。在饱和度色阶中，颜色的饱和度逐渐降低，但颜色的明度和色调保持不变。</p></li><li><p><strong>色调色阶</strong>：指的是颜色在色轮上从一种颜色到另一种颜色的渐变。色调色阶可以是单色（同一色调的不同明度和饱和度），也可以是多色（不同色调的组合）。</p></li><li><p><strong>互补色阶</strong>：指的是使用互补色（在色轮上相对位置的颜色）来创建对比和平衡的效果。</p></li><li><p><strong>暖色和冷色色阶</strong>：暖色通常包括红色、橙色和黄色，而冷色包括蓝色、绿色和紫色。通过暖色和冷色的渐变，可以创造出温暖或凉爽的感觉。</p></li><li><p><strong>渐变色阶</strong>：在数字艺术和设计中，渐变色阶常用于背景、图标和其他视觉元素，以增加视觉吸引力和深度。</p></li></ol><h3 id="游戏渲染"><a href="#游戏渲染" class="headerlink" title="游戏渲染"></a>游戏渲染</h3><p>在游戏渲染中，色阶（Color Grading）通常指的是通过调整颜色和亮度来模拟不同的光照效果，从而增强游戏的视觉风格和情感表达。色阶可以看作是游戏中颜色分级的一种技术，它允许开发者控制游戏中颜色的动态范围，从而创造出更加丰富和风格化的视觉体验。</p><p>在卡通渲染（Cartoon Rendering）或非真实感渲染（Non-Photorealistic Rendering, NPR）中，色阶的概念尤为重要。卡通渲染通过减少颜色的动态范围和明暗细节，模拟传统卡通或动漫中的视觉效果。这种渲染方式通常包括以下几个关键步骤：</p><ol><li><p><strong>光照模型的修改</strong>：通过修改传统的光照模型，如使用阶梯函数（Step Function）或颜色映射（Ramp Map）来控制阴影和高光的强度，从而实现色阶效果。</p></li><li><p><strong>颜色的简化</strong>：将复杂的颜色映射到较少的颜色阶梯上，使得颜色变化更加明显和风格化。</p></li><li><p><strong>描边（Outline）</strong>：为了增强轮廓和视觉层次感，卡通渲染通常会在物体的边缘添加颜色鲜明的描边。</p></li><li><p><strong>阴影和高光的颜色控制</strong>：通过为阴影和高光指定特定的颜色，可以进一步增强卡通渲染的效果。</p></li><li><p><strong>边缘光（Rim Lighting）</strong>：在角色或物体的边缘添加光晕，以增强立体感和视觉冲击力。</p></li><li><p><strong>后期处理</strong>：在渲染完成后，通过后期处理步骤进一步调整颜色和亮度，以实现最终的视觉风格。</p></li></ol><p>色阶在游戏渲染中的应用不仅限于卡通渲染，它也可以用于写实渲染中，通过调整颜色的动态范围来模拟不同的时间和环境氛围，或者强化游戏中的情感和故事元素。例如，可以通过色阶技术来模拟黎明、黄昏或特定天气条件下的光照效果。</p><p>总的来说，色阶是游戏渲染中一个强大的工具，它可以帮助开发者创造出符合游戏风格和情感需求的视觉体验。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 游戏美术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ShaderGraph实战</title>
      <link href="//ShaderGraph/ShaderGraph200/"/>
      <url>//ShaderGraph/ShaderGraph200/</url>
      
        <content type="html"><![CDATA[<h2 id="全息投影"><a href="#全息投影" class="headerlink" title="全息投影"></a>全息投影</h2><ul><li>不受光照用Unlit</li><li>很多效果需要贴图的助力</li><li>颜色值从黑色RGB(0,0,0)到白色(1,1.1)，其他颜色的RGB值处于0-1之间透明需要设置Master节点的Alpha输入和设置中的Surface改为Transparent</li><li>做动画要想到Time节点</li><li>要改变纹理的偏移需要用到Tiling And Offset节点</li></ul><h4 id="用到的节点"><a href="#用到的节点" class="headerlink" title="用到的节点"></a>用到的节点</h4><ul><li><a href="/ShaderGraph/ShaderGraph100/#%E5%9F%BA%E7%A1%80">Sample Texture 2D</a> 采样2D纹理节点</li><li><a href="/ShaderGraph/ShaderGraph100/#%E5%AE%9E%E7%94%A8%E5%8A%9F%E8%83%BD">Preview</a> 预览节点</li><li><a href="/ShaderGraph/ShaderGraph100/#UV">Tiling And Offset</a>平铺和偏移节点</li><li><a href="/ShaderGraph/ShaderGraph100/#%E5%9F%BA%E7%A1%80">Time</a> 时间节点</li><li><a href="/ShaderGraph/ShaderGraph100/#%E5%9F%BA%E7%A1%80">Float</a> 浮点数节点</li><li><a href="/ShaderGraph/ShaderGraph100/#%E5%9F%BA%E7%A1%80-1">Multiply</a> 乘法节点</li><li><a href="/ShaderGraph/ShaderGraph100/#%E5%87%A0%E4%BD%95%E5%AD%A6">Screen Position</a>屏幕空间坐标节点</li><li><a href="/ShaderGraph/ShaderGraph100/#%E5%87%A0%E4%BD%95%E5%AD%A6">Position</a> 世界空间坐标节点</li></ul><h2 id="边缘光"><a href="#边缘光" class="headerlink" title="边缘光"></a>边缘光</h2><ul><li>边缘效果通常需要用到Fresnel节点</li><li>颜色做运算的时候要考虑使用加法还是乘法</li></ul><h4 id="用到的节点-1"><a href="#用到的节点-1" class="headerlink" title="用到的节点"></a>用到的节点</h4><ul><li><a href="/ShaderGraph/ShaderGraph100/#%E5%90%91%E9%87%8F">Fresnel Effect</a> 菲涅尔效应节点</li><li><a href="/ShaderGraph/ShaderGraph100/#%E5%9F%BA%E7%A1%80">Color</a> 颜色节点</li><li><a href="/ShaderGraph/ShaderGraph100/#%E5%9F%BA%E7%A1%80-1">Multiply</a> 乘法节点</li><li><a href="/ShaderGraph/ShaderGraph100/#%E5%9F%BA%E7%A1%80">Float</a> 浮点数节点</li><li><a href="/ShaderGraph/ShaderGraph100/#%E5%9F%BA%E7%A1%80">Sample Texture 2D</a> 采样2D纹理节点</li><li><a href="/ShaderGraph/ShaderGraph100/#%E5%9F%BA%E7%A1%80-1">Add</a> 加法节点</li></ul><h2 id="溶解"><a href="#溶解" class="headerlink" title="溶解"></a>溶解</h2><ul><li>随机 &gt; Noise节点</li><li>透明度混合有半透明效果</li><li>和透明度测试(裁剪)只有全透明和不透明两种状态，性能更好</li><li>Step节点</li><li>颜色叠加用Add，颜色混合用Multiply</li></ul><h4 id="用到的节点-2"><a href="#用到的节点-2" class="headerlink" title="用到的节点"></a>用到的节点</h4><ul><li><a href="/ShaderGraph/ShaderGraph100/#%E5%9F%BA%E7%A1%80">Sample Texture 2D</a> 采样2D纹理节点</li><li><a href="/ShaderGraph/ShaderGraph100/#%E5%99%AA%E5%A3%B0">Simple Noise</a> Simple Noise 节点</li><li><a href="/ShaderGraph/ShaderGraph100/#%E5%9F%BA%E7%A1%80">SliderSlider</a> Slider 节点</li><li><a href="/ShaderGraph/ShaderGraph100/#%E5%9F%BA%E7%A1%80">Subtract</a> 减法节点</li><li><a href="/ShaderGraph/ShaderGraph100/#%E5%8F%96%E6%95%B4">Step</a> Step 节点</li><li><a href="/ShaderGraph/ShaderGraph100/#%E5%9F%BA%E7%A1%80">Color</a> 颜色节点</li><li><a href="/ShaderGraph/ShaderGraph100/#%E5%9F%BA%E7%A1%80-1">Add</a> 加法节点</li></ul><h2 id="积雪"><a href="#积雪" class="headerlink" title="积雪"></a>积雪</h2><ul><li>运用SubGraph子图来创建自定义节点，在多个图中复用</li><li>利用向量的点乘运算，来计算两个向量的相似程度</li></ul><h4 id="用到的节点-3"><a href="#用到的节点-3" class="headerlink" title="用到的节点"></a>用到的节点</h4><ul><li><a href="/ShaderGraph/ShaderGraph100/#%E5%9F%BA%E7%A1%80">Sample Texture 2D</a> 采样2D纹理节点</li><li><a href="/ShaderGraph/ShaderGraph100/#%E5%9F%BA%E7%A1%80-1">Multiply</a> 乘法节点</li><li><a href="/ShaderGraph/ShaderGraph100/#%E5%9F%BA%E7%A1%80-1">Add</a> 加法节点</li><li><a href="/ShaderGraph/ShaderGraph100/#%E6%B3%95%E7%BA%BF">Normal Vector</a> 法线向量</li><li><a href="/ShaderGraph/ShaderGraph100/#%E5%90%91%E9%87%8F">Dot Product</a> 点乘节点</li><li><a href="/ShaderGraph/ShaderGraph100/#%E5%8F%96%E6%95%B4">Step</a> Step 节点</li><li><a href="/ShaderGraph/ShaderGraph100/#%E5%9F%BA%E7%A1%80">Float</a> 浮点数节点</li></ul><h2 id="扭曲"><a href="#扭曲" class="headerlink" title="扭曲"></a>扭曲</h2><ul><li>产生随机 -&gt;Noise节点</li><li>产生扭曲的效果-&gt;Twirl节点</li><li>产生动画-&gt;Time节点</li><li>更改输出的形状-&gt;Procedural&gt;Shape中的多个形状节点</li></ul><h4 id="用到的节点-4"><a href="#用到的节点-4" class="headerlink" title="用到的节点"></a>用到的节点</h4><ul><li><a href="/ShaderGraph/ShaderGraph100/#UV">Twirl</a> Twirl 节点</li><li><a href="/ShaderGraph/ShaderGraph100/#%E5%99%AA%E5%A3%B0">Voronoi</a> Voronoi 节点</li><li><a href="/ShaderGraph/ShaderGraph100/#%E5%9F%BA%E7%A1%80">Color</a> 颜色节点</li><li><a href="/ShaderGraph/ShaderGraph100/#%E5%9F%BA%E7%A1%80-1">Multiply</a> 乘法节点</li><li><a href="/ShaderGraph/ShaderGraph100/#%E5%9F%BA%E7%A1%80">Time</a> 时间节点</li><li><a href="/ShaderGraph/ShaderGraph100/#%E5%BD%A2%E7%8A%B6">Ellipse</a> 椭圆节点</li></ul><h2 id="干扰效果"><a href="#干扰效果" class="headerlink" title="干扰效果"></a>干扰效果</h2><ul><li>贴图产生变形的效果 &gt;修改UV</li><li>动画 &gt;Time节点</li><li>动画速度 &gt;添加速度属性，和Time节点做运算</li></ul><h4 id="用到的节点-5"><a href="#用到的节点-5" class="headerlink" title="用到的节点"></a>用到的节点</h4><ul><li><a href="/ShaderGraph/ShaderGraph100/#%E5%87%A0%E4%BD%95%E5%AD%A6">UV</a></li><li><a href="/ShaderGraph/ShaderGraph100/#%E9%80%9A%E9%81%93">Split</a></li><li><a href="/ShaderGraph/ShaderGraph100/#%E5%99%AA%E5%A3%B0">Simple Noise</a> Simple Noise 节点</li><li><a href="/ShaderGraph/ShaderGraph100/#%E5%9F%BA%E7%A1%80">Vector2</a> 二维向量节点</li><li><a href="/ShaderGraph/ShaderGraph100/#%E5%9F%BA%E7%A1%80-1">Add</a> 加法</li><li><a href="/ShaderGraph/ShaderGraph100/#%E5%9F%BA%E7%A1%80">Sample Texture 2D</a> 采样2D纹理节点</li><li><a href="/ShaderGraph/ShaderGraph100/#%E5%9F%BA%E7%A1%80">Time</a> 时间节点</li></ul><h2 id="流光效果"><a href="#流光效果" class="headerlink" title="流光效果"></a>流光效果</h2><ul><li>贴图位置变化 &gt;修改UV</li><li>根据贴图运动的空间选择UV空间</li><li>动画 &gt;Time节点</li></ul><h3 id="2D流光"><a href="#2D流光" class="headerlink" title="2D流光"></a>2D流光</h3><h4 id="用到的节点-6"><a href="#用到的节点-6" class="headerlink" title="用到的节点"></a>用到的节点</h4><ul><li>[Sample Texture 2D] 原图+流光图</li><li>[Add]</li><li>[Time]</li><li>[Tiling And Offset]</li><li>[Vector2] input x out (x,0)</li><li>[Multiply]</li><li>[Float] 设置speed</li></ul><h3 id="3D流光"><a href="#3D流光" class="headerlink" title="3D流光"></a>3D流光</h3><ul><li><a href="/ShaderGraph/ShaderGraph100/#%E5%87%A0%E4%BD%95%E5%AD%A6">Screen Position</a>屏幕空间坐标节点</li><li><a href="/ShaderGraph/ShaderGraph100/#%E5%87%A0%E4%BD%95%E5%AD%A6">Position</a> 世界空间坐标节点 Space（World或Object）区别<br>上面设置到 [Tiling And Offset] 的UV输入</li></ul><h2 id="石化"><a href="#石化" class="headerlink" title="石化"></a>石化</h2><ul><li>渐变效果 &gt; Lerp节点</li><li>通过代码控制材质的属性，记得设置属性的Reference</li></ul><h4 id="用到的节点-7"><a href="#用到的节点-7" class="headerlink" title="用到的节点"></a>用到的节点</h4><ul><li>[Sample Texture 2D] 原图+石化图</li><li>[Lerp]</li><li>[Multiply]</li></ul><h1 id="修改顶点实现效果"><a href="#修改顶点实现效果" class="headerlink" title="修改顶点实现效果"></a>修改顶点实现效果</h1><h2 id="跳动小球"><a href="#跳动小球" class="headerlink" title="跳动小球"></a>跳动小球</h2><ul><li>通过修改Position可以在Mesh不变的情况下修改位置&#x2F;形状</li></ul><h4 id="用到的节点-8"><a href="#用到的节点-8" class="headerlink" title="用到的节点"></a>用到的节点</h4><ul><li>[Normal Vector]</li><li>[Multiply]</li><li>[Time]</li><li>[Simple Noise]</li><li>[Tiling And Offset]</li><li>[Position]</li></ul><h2 id="游动的鱼"><a href="#游动的鱼" class="headerlink" title="游动的鱼"></a>游动的鱼</h2><p>学习好三角函数</p><h4 id="用到的节点-9"><a href="#用到的节点-9" class="headerlink" title="用到的节点"></a>用到的节点</h4><ul><li>[Sine]</li></ul><h2 id="小草摇摆"><a href="#小草摇摆" class="headerlink" title="小草摇摆"></a>小草摇摆</h2><ul><li>使用Position节点考虑修改单个物体还是在世界坐标系中的位置</li><li>Transform节点可以在不同坐标系下转换</li><li>（加（0-1）的值-0.5能获取到一个（-0.5到0.5）的值）</li><li>弱一点效果 （0-1）的值先减0.5 再乘于一个系数 再加到 原来的X</li></ul><h4 id="用到的节点-10"><a href="#用到的节点-10" class="headerlink" title="用到的节点"></a>用到的节点</h4><ul><li>[Position]</li><li>[Transform]</li><li>[Time]</li><li>[UV]</li><li>[Tiling And Offset]</li><li>[Simple Noise]</li><li>[Lerp]</li><li>[Multiply]</li><li>[Add]</li><li>[Subtract]</li><li>[Split] 获取X取R通道</li><li>[Combine]</li></ul><h2 id="简单水面"><a href="#简单水面" class="headerlink" title="简单水面"></a>简单水面</h2><ul><li>法线混合</li></ul><h4 id="用到的节点-11"><a href="#用到的节点-11" class="headerlink" title="用到的节点"></a>用到的节点</h4><ul><li>[Normal Blend] 法线混合节点</li><li>[Multiply] 乘法节点</li><li>[Lerp] 线性插值节点</li><li>[Fresnel Effect] 菲涅尔效应节点</li><li>[Time]</li><li>[Color]</li><li>[Float]</li></ul><h2 id="水晶效果"><a href="#水晶效果" class="headerlink" title="水晶效果"></a>水晶效果</h2><ul><li>视差 View Direction和Offset属性做乘法运算</li></ul><h4 id="用到的节点-12"><a href="#用到的节点-12" class="headerlink" title="用到的节点"></a>用到的节点</h4><ul><li>[Sample Texture 2D] 采样2D纹理节点</li><li>[Multiply] 乘法节点</li><li>[Color] 颜色节点</li><li>[Add] 加法节点</li><li>[Fresnel Effect] 菲涅尔效应节点 （外发光）<br>(内发光)</li><li>[One Minus] 1-x节点</li></ul><h2 id="雨滴涟漪"><a href="#雨滴涟漪" class="headerlink" title="雨滴涟漪"></a>雨滴涟漪</h2><ul><li>Flipbook节点，用于动画序列帧图片</li><li>Voronoi，类似细胞分布的程序化噪点图</li></ul><h4 id="用到的节点-13"><a href="#用到的节点-13" class="headerlink" title="用到的节点"></a>用到的节点</h4><ul><li>[Flipbook] 动画序列帧节点</li><li>[Voronoi] 噪声节点</li><li>[Multiply] 乘法节点</li><li>[Color] 颜色节点</li><li>[Time] 时间节点</li><li>[Float] 浮点数节点</li><li>[Normal Blend] 法线混合节点</li><li>[Normal Strength] 法线强度节点</li><li>[Tiling And Offset] 平铺和偏移节点</li><li>[Simple Texture2d] 采样2D纹理节点</li></ul><h2 id="卡通渲染描边效果"><a href="#卡通渲染描边效果" class="headerlink" title="卡通渲染描边效果"></a>卡通渲染描边效果</h2>]]></content>
      
      
      <categories>
          
          <category> ShaderGraph </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ShaderGraph </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ShaderGraph节点学习</title>
      <link href="//ShaderGraph/ShaderGraph100/"/>
      <url>//ShaderGraph/ShaderGraph100/</url>
      
        <content type="html"><![CDATA[<h1 id="美术"><a href="#美术" class="headerlink" title="美术"></a>美术</h1><h2 id="调整"><a href="#调整" class="headerlink" title="调整"></a>调整</h2><ul><li><a href="https://docs.unity3d.com/Packages/com.unity.shadergraph@17.0/manual/Invert-Colors-Node.html">Invert Colors</a> 反转颜色节点</li></ul><h2 id="法线"><a href="#法线" class="headerlink" title="法线"></a>法线</h2><ul><li><a href="https://docs.unity3d.com/Packages/com.unity.shadergraph@17.0/manual/Normal-Vector-Node.html">Normal Vector</a> 法线向量</li><li><a href="https://docs.unity3d.com/Packages/com.unity.shadergraph@17.0/manual/Normal-Blend-Node.html">Normal Blend</a> 法线混合节点</li><li><a href="https://docs.unity3d.com/Packages/com.unity.shadergraph@17.0/manual/Normal-Strength-Node.html">Normal Strength</a> 法线强度节点</li></ul><h1 id="通道"><a href="#通道" class="headerlink" title="通道"></a>通道</h1><ul><li><a href="https://docs.unity3d.com/Packages/com.unity.shadergraph@17.0/manual/Combine-Node.html?q=Combine">Combine</a>  将四个输入通道（R、G、B、A）合并成一个输出通道。</li><li><a href="https://docs.unity3d.com/Packages/com.unity.shadergraph@17.0/manual/Split-Node.html?q=Split">Split</a>  将输入矢量 In<br>分成四个 Float 输出：R、G、B 和 A。这些输出矢量由输入 In 的各个通道定义：分别是红色、绿色、蓝色和 Alpha。如果输入矢量 In 的维度小于<br>4（矢量 4），则输入中不存在的输出值将为 0。</li></ul><h1 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><ul><li><a href="https://docs.unity3d.com/cn/Packages/com.unity.shadergraph@10.5/manual/Time-Node.html">Time</a> 时间节点</li><li><a href="https://docs.unity3d.com/Packages/com.unity.shadergraph@17.0/manual/Float.html">Float</a> 浮点数节点</li><li><a href="https://docs.unity3d.com/Packages/com.unity.shadergraph@17.0/manual/Color-Node.html?q=Color">Color</a> 颜色节点</li><li><a href="https://docs.unity3d.com/Packages/com.unity.shadergraph@17.0/manual/Slider-Node.html">Slider</a> Slider 节点</li><li><a href="https://docs.unity3d.com/Packages/com.unity.shadergraph@17.0/manual/Vector-2-Node.html">Vector 2</a> 二维向量节点</li><li><a href="https://docs.unity3d.com/Packages/com.unity.shadergraph@17.0/manual/Vector-3-Node.html">Vector 3</a> 三维向量节点</li></ul><h2 id="几何学"><a href="#几何学" class="headerlink" title="几何学"></a>几何学</h2><ul><li><a href="https://docs.unity3d.com/Packages/com.unity.shadergraph@17.0/manual/Screen-Position-Node.html?q=screen%20p">Screen Position</a><br>屏幕空间坐标节点</li><li><a href="https://docs.unity3d.com/Packages/com.unity.shadergraph@17.0/manual/Position-Node.html">Position</a> 世界空间坐标节点</li><li><a href="https://docs.unity3d.com/Packages/com.unity.shadergraph@17.0/manual/UV-Node.html?q=UV">UV</a>  允许访问网格顶点或片元的<br>UV 坐标。可使用 Channel 下拉选单参数选择输出值的坐标通道。</li><li><a href="https://docs.unity3d.com/Packages/com.unity.shadergraph@17.0/manual/View-Direction-Node.html">View Direction</a> 视线方向节点</li></ul><h2 id="纹理"><a href="#纹理" class="headerlink" title="纹理"></a>纹理</h2><ul><li><a href="https://docs.unity3d.com/Packages/com.unity.shadergraph@17.0/manual/Sample-Texture-2D-Node.html">Sample Texture 2D</a><br>采样2D纹理节点</li></ul><h1 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h1><h2 id="基础-1"><a href="#基础-1" class="headerlink" title="基础"></a>基础</h2><ul><li><a href="https://docs.unity3d.com/Packages/com.unity.shadergraph@17.0/manual/Multiply-Node.html">Multiply</a> 乘法节点</li><li><a href="https://docs.unity3d.com/Packages/com.unity.shadergraph@17.0/manual/Add-Node.html?q=Add">Add</a> 加法节点</li><li><a href="https://docs.unity3d.com/Packages/com.unity.shadergraph@17.0/manual/Subtract-Node.html">Subtract</a> 减法节点</li></ul><h2 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h2><ul><li><a href="https://docs.unity3d.com/Packages/com.unity.shadergraph@17.0/manual/Dot-Product-Node.html">Dot Product</a> 点乘节点  获取相近的值</li><li><a href="https://docs.unity3d.com/Packages/com.unity.shadergraph@17.0/manual/Fresnel-Effect-Node.html">Fresnel Effect</a> 菲涅尔效应节点</li><li><a href="https://docs.unity3d.com/Packages/com.unity.shadergraph@17.0/manual/Transform-Node.html">Transform</a> 返回将输入值 (In) 从一个坐标空间变换为另一个坐标空间的结果。选择节点上的下拉选项来定义变换的起始空间和目标空间。</li></ul><h2 id="取整"><a href="#取整" class="headerlink" title="取整"></a>取整</h2><ul><li><a href="https://docs.unity3d.com/Packages/com.unity.shadergraph@17.0/manual/Step-Node.html?q=Step">Step</a> Step 节点</li></ul><h2 id="插值"><a href="#插值" class="headerlink" title="插值"></a>插值</h2><ul><li><a href="https://docs.unity3d.com/Packages/com.unity.shadergraph@17.0/manual/Lerp-Node.html">Lerp</a> Lerp 节点</li></ul><h2 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h2><ul><li><a href="https://docs.unity3d.com/Packages/com.unity.shadergraph@17.0/manual/One-Minus-Node.html">One Minus</a> 1减法节点</li><li><a href="https://docs.unity3d.com/Packages/com.unity.shadergraph@17.0/manual/Remap-Node.html">Remap</a> 根据输入 In 值在输入 In Min Max 的 x 和 y 分量之间的线性插值，返回输入 Out Min Max 的 x 和 y 分量之间的值。</li></ul><h2 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h2><ul><li><a href="https://docs.unity3d.com/Packages/com.unity.shadergraph@17.0/manual/Sine-Node.html">Sine</a> Sine 节点</li></ul><h1 id="程序化"><a href="#程序化" class="headerlink" title="程序化"></a>程序化</h1><h2 id="噪声"><a href="#噪声" class="headerlink" title="噪声"></a>噪声</h2><ul><li><a href="https://docs.unity3d.com/Packages/com.unity.shadergraph@17.0/manual/Simple-Noise-Node.html">Simple Noise</a> Simple Noise 节点</li><li><a href="https://docs.unity3d.com/Packages/com.unity.shadergraph@17.0/manual/Voronoi-Node.html">Voronoi</a> Voronoi 节点</li><li><a href="https://docs.unity3d.com/cn/Packages/com.unity.shadergraph@10.5/manual/Gradient-Noise-Node.html">Gradient Noise</a><br>Gradient Noise 节点 根据输入 UV 生成渐变或柏林噪声。生成噪声的比例由输入 Scale 控制。</li></ul><h2 id="形状"><a href="#形状" class="headerlink" title="形状"></a>形状</h2><ul><li><a href="https://docs.unity3d.com/Packages/com.unity.shadergraph@17.0/manual/Ellipse-Node.html">Ellipse</a> Ellipse 节点 以输入<br>Width 和 Height 指定的大小基于输入 UV 生成椭圆形状</li></ul><h1 id="实用功能"><a href="#实用功能" class="headerlink" title="实用功能"></a>实用功能</h1><ul><li><a href="https://docs.unity3d.com/Packages/com.unity.shadergraph@17.0/manual/Preview-Node.html">Preview</a> 预览节点</li></ul><h1 id="UV"><a href="#UV" class="headerlink" title="UV"></a>UV</h1><ul><li><a href="https://docs.unity3d.com/Packages/com.unity.shadergraph@17.0/manual/Flipbook-Node.html?q=Flipbook">Flipbook</a> 使用向输入 UV 提供的 UV 创建翻页或纹理帧动画。纹理层上的区块数量由输入 Width 和 Height 的值定义。当前区块的索引由输入 Tile 的值定义。</li><li><a href="https://docs.unity3d.com/Packages/com.unity.shadergraph@17.0/manual/Tiling-And-Offset-Node.html">Tiling And Offset</a><br>平铺和偏移节点</li><li><a href="https://docs.unity3d.com/Packages/com.unity.shadergraph@17.0/manual/Twirl-Node.html?q=Twirl">Twirl</a> Twirl 节点<br>将类似于黑洞的旋转变形效果应用于输入 UV 的值</li></ul><h1 id="Block节点"><a href="#Block节点" class="headerlink" title="Block节点"></a>Block节点</h1>]]></content>
      
      
      <categories>
          
          <category> ShaderGraph </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ShaderGraph </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ShaderGraph 关键字</title>
      <link href="//ShaderGraph/ShaderGraph004/"/>
      <url>//ShaderGraph/ShaderGraph004/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>您可以使用关键字为 Shader Graph 创建不同的变体。根据关键字的设置和编辑器中的设置，构建管线可能会剥离这些变体。</p><p>关键字的用途很多，例如：</p><p>创建具有可为每个材质实例打开或关闭的功能的着色器。<br>创建具有在某些平台上表现不同的功能的着色器。<br>创建可根据各种条件扩展复杂度的着色器。</p><p>关键字分为三种类型：Boolean、Enum 和 Built-in。根据其类型，Unity<br>在图形、着色器以及材质检视面板（可选）中定义了一个关键字。有关关键字类型的更多信息，请参阅<a href="#%E5%B8%83%E5%B0%94%E5%85%B3%E9%94%AE%E5%AD%97">布尔关键字</a>、<a href="#">Enum 关键字</a><br>和<a href="#">Built-in 关键字</a>。有关这些关键字如何影响最终着色器的更多信息，请参阅有关编写多个着色器程序变体文档。</p><p>在 Shader Graph 中，首先在 <a href="../ShaderGraph001/#Blackboard%E5%B1%9E%E6%80%A7%E9%9D%A2%E6%9D%BF">Blackboard</a><br>上定义一个关键字，然后使用一个 <a href="#">Keyword 节点</a>在图形中创建一个分支。</p><p>编辑器能够在需要变体来呈现内容时按需编译变体。如果你声明许多不同的变体，你最终可能会得到数百万或数万亿种可能性。但是，播放器需要在构建时确定正在使用哪些变体，并在预编译着色器时包含它们。为了有效地管理内存，播放机会根据其关键字和编辑器设置剥离未使用的变体。请参阅下一节“通用参数”，详细了解如何向播放器提供提示，说明它需要编译的内容以及可以忽略的内容。当播放机在生成过程中剥离变体时，它会显示粉红色错误着色器。</p><h2 id="通用参数"><a href="#通用参数" class="headerlink" title="通用参数"></a>通用参数</h2><p>尽管特定类型的关键字有其特定的字段，但所有关键字都具有以下参数。</p><table><thead><tr><th>名称</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>Display Name(显示名称)</td><td>字符串</td><td>关键字的显示名称。Unity 会在引用相应关键字的节点的标题栏中显示此名称，如果暴露该关键字，也会在<strong>材质检视面板</strong>中显示此名称。</td></tr><tr><td>Exposed (暴露)</td><td>布尔值 (Boolean)</td><td>如果将其设置为 true，Unity 在材质检视面板中显示相应的关键字。如果将其设置为 false，关键字不会出现在材质检视面板中。<br/>如果要访问 GLOBAL 着色器变量，请确保像通常添加输入变量一样添加它，但取消选择 Exposed。</td></tr><tr><td>Reference Name (引用名称)</td><td>字符串</td><td>关键字在着色器中的内部名称。  <br/>如果您覆盖了此参数，请注意以下几点：<br/>1. 关键字 Reference Name 始终为全大写，因此 Unity 将所有小写字母转换为大写字母。<br/>2. 如果 Reference Name 包含任何 HLSL 不支持的字符，Unity 将用下划线替换这些字符。<br/>3. 右键单击 Reference Name，然后选择 Reset Reference 可恢复为默认的 Reference Name。</td></tr><tr><td>Definition   (定义)</td><td>枚举</td><td>设置关键字在着色器中的定义方式。确定何时编译关键字变体。<br/>有三个可用选项。<br/>1. Shader Feature：Unity 在构建时剥离未使用的着色器变体。<br/>2. Multi Compile：Unity 从不剥离任何着色器变体。<br/>2. Predefined：表示活动的渲染管线已经定义了这个关键字，所以 Shader Graph 在它生成的代码中不再对其进行定义。</td></tr><tr><td>Scope  (范围)</td><td>枚举</td><td>设置定义关键字的范围。<br/>1. Global Keywords：为整个项目定义关键字，并计入全局关键字限制。<br/>2. Local Keywords：只为一个着色器定义关键字，它有自己的本地关键字限制。  <br/>3.使用预定义关键字时，Unity 将禁用此字段。</td></tr><tr><td>Stages  (阶段)</td><td></td><td>设置关键字适用的阶段。<br/>可以使用以下选项：<br/>1.<strong>全部</strong> - 将此关键字应用于所有着色器阶段。<br/>2.<strong>顶点</strong> - 将此关键字应用于顶点阶段。<br/>3.<strong>片段</strong> - 将此关键字应用于片段阶段。</td></tr></tbody></table><h2 id="布尔关键字"><a href="#布尔关键字" class="headerlink" title="布尔关键字"></a>布尔关键字</h2><p>布尔关键字要么打开，要么关闭。这会产生两个着色器变体。如果 Exposed 参数设置为 true 时，Unity 会在 Material Inspector<br>中公开布尔关键字。若要从脚本启用关键字，请在关键字的引用名称上使用 EnableKeyword。DisableKeyword<br>禁用关键字。要了解有关布尔关键字的详细信息，请参阅<a href="https://docs.unity3d.com/Manual/SL-MultipleProgramVariants.html">着色器变体和关键字</a>。</p><h3 id="特定于类型的参数"><a href="#特定于类型的参数" class="headerlink" title="特定于类型的参数"></a>特定于类型的参数</h3><p>除了上面列出的常用参数外，布尔关键字还有一个特定于布尔值的参数。</p><table><thead><tr><th>名字</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>Default</td><td>布尔</td><td>启用此参数可将关键字的默认状态设置为打开，禁用此参数可将关键字的默认状态设置为关闭。<br/> 此参数确定着色器图生成预览时要用于关键字的值。它还定义了使用此着色器创建新材质时关键字的默认值。</td></tr></tbody></table><h2 id="Enum-关键字"><a href="#Enum-关键字" class="headerlink" title="Enum 关键字"></a>Enum 关键字</h2><p>枚举关键字可以有两个或更多状态，这些状态由您在 条目 列表中定义。如果您暴露一个枚举关键字，其 条目 列表中的 显示名称 会出现在材质检查器的下拉菜单中。</p><p>在枚举关键字的 条目名称 中，特殊字符如 ( ) 或 ! @ 是无效的。Shader Graph 会将无效字符转换为下划线 ( _ )。</p><p>当您定义一个枚举关键字时，Shader Graph 会显示每个状态的标签，由枚举的 条目名称 的净化版本附加到主 引用名称。</p><p>通过脚本使用 Material.EnableKeyword 或 Shader.EnableKeyword 函数 控制关键字时，以 {REFERENCE}_{REFERENCESUFFIX} 的格式输入状态标签。例如，如果您的引用名称是 MYENUM 并且所需的条目是 OPTION1，那么您将调用 Material.EnableKeyword(“MYENUM_OPTION1”)。当您选择一个选项时，这会禁用其他选项。</p><h3 id="特定于类型的参数-1"><a href="#特定于类型的参数-1" class="headerlink" title="特定于类型的参数"></a>特定于类型的参数</h3><p>除了上面列出的常用参数外，枚举关键字还具有以下附加参数。</p><table><thead><tr><th>名字</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>Default</td><td>枚举</td><td>从下拉菜单中选择一个条目，以确定在 Shader Graph 生成预览时将哪个值用于关键字。这也定义了使用此着色器创建新材质时关键字的默认值。编辑“条目”列表时，Shader Graph 会自动更新此控件中的选项。</td></tr><tr><td>Entries</td><td>Reorderable List(可重新排序列表)</td><td>此列表定义关键字的所有状态。每个状态都有单独的“显示名称”和“引用后缀”。<br/>• 显示名称：显示在关键字的下拉菜单中内部检查员和材料检查员。Shader Graph 还对引用关键字的节点上的端口标签使用此名称。<br/> • 参考后缀：这是最后一个关键字，以.Reference_ReferenceSuffix</td></tr></tbody></table><h2 id="Built-in-关键字"><a href="#Built-in-关键字" class="headerlink" title="Built-in 关键字"></a>Built-in 关键字</h2><p>内置关键字始终是布尔型或枚举型，但它们的行为与您创建的布尔型或枚举型关键字略有不同。Unity 编辑器或活动的渲染管线设置它们的值，您无法编辑这些。</p><p>在图检查器的 节点设置 标签中，所有内置关键字字段都是灰色的，除了可以启用或禁用以显示 Shader Graph 预览中差异的 默认值 字段。您也无法在材质检查器中暴露内置关键字。</p><p>在 HDRP 项目中，您可以在 HDRP 资产的材料部分找到当前的质量级别。对于 URP 项目，不支持此功能，但您可以使用 SetGlobalShaderKeywords 命令在脚本中设置 MaterialQuality 枚举。例如，以下行将材料质量设置为高：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MaterialQualityUtilities.SetGlobalShaderKeywords(MaterialQuality.High);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ShaderGraph </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ShaderGraph </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ShaderGraph 数据类型</title>
      <link href="//ShaderGraph/ShaderGraph003/"/>
      <url>//ShaderGraph/ShaderGraph003/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Shader Graph 中有许多数据类型。<a href="#">节点</a>上的每个端口都有一个关联的数据类型，用于定义可以连接到哪些边。数据类型具有可用性颜色，这些颜色应用于该数据类型的端口和边。<br>有些数据类型具有关联的<a href="../ShaderGraph002">属性类型</a><br>，用于将这些值显示给使用着色器的材质的 <a href="https://docs.unity3d.com/Manual/UsingTheInspector.html">Inspector</a>。</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><table><thead><tr><th>名称</th><th>颜色</th><th>描述</th></tr></thead><tbody><tr><td>Float</td><td>浅蓝</td><td>一个 Float 或标量值</td></tr><tr><td>Vector 2</td><td>绿色</td><td>一个矢量 2 值。</td></tr><tr><td>Vector 3</td><td>黄色</td><td>一个矢量 3 值。</td></tr><tr><td>Vector 4</td><td>粉红色</td><td>一个矢量 4 值。</td></tr><tr><td>Dynamic Vector</td><td>浅蓝</td><td>请参阅下面的动态数据类型</td></tr><tr><td>Matrix 2</td><td>蓝色</td><td>一个矩阵 2x2 值</td></tr><tr><td>Matrix 3</td><td>蓝色</td><td>一个矩阵 3x3 值</td></tr><tr><td>Matrix 4</td><td>蓝色</td><td>一个矩阵 4x4 值</td></tr><tr><td>Dynamic Matrix</td><td>蓝色</td><td>请参阅下面的动态数据类型</td></tr><tr><td>Dynamic</td><td>蓝色</td><td>请参阅下面的动态数据类型</td></tr><tr><td>Boolean</td><td>紫色</td><td>一个布尔值。在生成的着色器中定义为浮点数</td></tr><tr><td>Texture 2D</td><td>红色</td><td>一个 <a href="https://docs.unity3d.com/Manual/class-TextureImporter.html">2D 纹理</a> 资源</td></tr><tr><td>Texture 2D Array</td><td>红色</td><td>一个 <a href="https://docs.unity3d.com/Manual/class-TextureImporter.html">2D 纹理数组</a>资源</td></tr><tr><td>Texture 3D</td><td>红色</td><td>一个 <a href="https://docs.unity3d.com/Manual/class-TextureImporter.html">3D 纹理</a> 资源</td></tr><tr><td>Cubemap</td><td>红色</td><td>一个<a href="https://docs.unity3d.com/Manual/class-TextureImporter.html">立方体贴图</a>资源</td></tr><tr><td>Virtual Texture</td><td>灰色</td><td>一个<a href="https://docs.unity3d.com/2020.1/Documentation/Manual/svt-use-in-shader-graph.html">纹理堆栈</a></td></tr><tr><td>Gradient</td><td>灰色</td><td>一个Gradient(渐变)值。在生成的着色器中定义为结构</td></tr><tr><td>SamplerState</td><td>灰色</td><td>用于对纹理进行采样的状态。</td></tr></tbody></table><h2 id="提升-截断"><a href="#提升-截断" class="headerlink" title="提升&#x2F;截断"></a>提升&#x2F;截断</h2><p>可以提升或截断所有矢量类型以匹配任何矢量类型端口。仅当相关的端口不是动态矢量类型时，才会发生此行为。截断时将会直接移除多余的通道。在提升时，所需的额外通道将填充默认值。这些值为 (0, 0, 0, 1)。</p><h2 id="动态数据类型"><a href="#动态数据类型" class="headerlink" title="动态数据类型"></a>动态数据类型</h2><p>有些数据类型是<strong>动态</strong>的。这意味着使用这些数据类型的端口可以根据与其连接的数据类型更改其基础的实际数据类型。默认情况下，使用动态数据类型的<a href="#">节点</a>只能有一个<strong>实际数据类型</strong>，这意味着一旦连接的边将其数据类型应用于该端口，该节点的所有其他动态数据类型字段将应用相同的<strong>数据类型</strong>。</p><p>一个值得注意的例外是 <a href="#">Multiply 节点</a>，该节点允许动态矩阵和矢量类型。</p><h3 id="动态-Vector"><a href="#动态-Vector" class="headerlink" title="动态 Vector"></a>动态 Vector</h3><p>动态矢量类型允许任何矢量类型的连接边。除非最低维度为 1（在这种情况下将提升 Float），否则所有连接边将自动截断为具有最低维度的类型。</p><h3 id="动态-Matrix"><a href="#动态-Matrix" class="headerlink" title="动态 Matrix"></a>动态 Matrix</h3><p>动态矩阵类型允许任何矩阵类型的连接边。所有连接边将自动截断为具有最低维度的类型。</p><h3 id="动态"><a href="#动态" class="headerlink" title="动态"></a>动态</h3><p>动态类型是一种特殊情况。支持该类型的<a href="#">节点</a>必须定义其验证方式。在 <a href="#">Multiply 节点</a>的情况下，可允许任何矢量或矩阵类型的连接，从而确保根据数据类型的混合应用正确的乘法。</p>]]></content>
      
      
      <categories>
          
          <category> ShaderGraph </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ShaderGraph </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ShaderGraph 属性类型</title>
      <link href="//ShaderGraph/ShaderGraph002/"/>
      <url>//ShaderGraph/ShaderGraph002/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>属性类型是可以在 <a href="../ShaderGraph001/#Blackboard%E5%B1%9E%E6%80%A7%E9%9D%A2%E6%9D%BF">Blackboard</a>上定义以在图形中使用的属性类型。这些属性将会显示在使用着色器的材质的 <a href="https://docs.unity3d.com/Manual/UsingTheInspector.html">Inspector</a><br>中。</p><p>每个属性都有一个关联的数据类型。请参阅<a href="../ShaderGraph003/">数据类型</a>以了解更多信息。</p><h2 id="通用参数"><a href="#通用参数" class="headerlink" title="通用参数"></a>通用参数</h2><p>除了特定于<a href="../ShaderGraph003/">数据类型</a>的值之外，大多数属性都具有以下通用参数。</p><table><thead><tr><th>名称</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>Display Name(显示名称)</td><td>字符串</td><td>属性的显示名称</td></tr><tr><td>Exposed(公开)</td><td>布尔值 (Boolean)</td><td>如果为 true，此属性将在材质检视面板上显示</td></tr><tr><td>Reference Name(引用名称)</td><td>字符串</td><td>在着色器内用于属性的内部名称</td></tr><tr><td>Override Property Declaration(覆盖属性声明)</td><td>布尔值 (Boolean)</td><td>一个高级选项，能够显式控制此属性的着色器声明</td></tr><tr><td>Shader Declaration(着色器声明)</td><td>枚举</td><td>控制此属性的着色器声明</td></tr></tbody></table><p>注意：如果要覆盖 Reference Name 参数，请注意以下情况：</p><ul><li>如果 Reference Name 不以下划线开头，则会自动附加一个下划线字符。</li><li>如果 Reference Name 包含 HLSL 不支持的任何字符，则会删除这些字符。</li><li>可以恢复到默认的 Reference Name，方法是右键单击该名称并选择 Reset Reference。</li></ul><hr><h2 id="Float"><a href="#Float" class="headerlink" title="Float"></a>Float</h2><p>定义一个 Float 值。</p><table><thead><tr><th>数据类型</th><th>模式</th></tr></thead><tbody><tr><td>Float</td><td>默认值、滑动条、整数</td></tr></tbody></table><h3 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h3><p>在材质检视面板中显示一个标量输入字段。</p><table><thead><tr><th>字段</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>Default</td><td>Float</td><td>属性的默认值</td></tr></tbody></table><h3 id="滑动条"><a href="#滑动条" class="headerlink" title="滑动条"></a>滑动条</h3><p>在材质检视面板中显示一个滑动条字段。</p><table><thead><tr><th>字段</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>Default</td><td>Float</td><td>属性的默认值</td></tr><tr><td>Min</td><td>Float</td><td>滑动条的最小值</td></tr><tr><td>Max</td><td>Float</td><td>滑动条的最大值</td></tr></tbody></table><h3 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h3><p>在材质检视面板中显示一个整数输入字段。</p><table><thead><tr><th>字段</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>Default</td><td>Float</td><td>属性的默认值</td></tr></tbody></table><hr><h2 id="Vector-2"><a href="#Vector-2" class="headerlink" title="Vector 2"></a>Vector 2</h2><p>定义一个Vector 2 值。在材质检视面板中显示一个Vector 4 输入字段，其中不使用 z 和 w 分量。</p><table><thead><tr><th>数据类型</th><th>模式</th></tr></thead><tbody><tr><td>Vector 2</td><td></td></tr></tbody></table><table><thead><tr><th>字段</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>Default</td><td>Vector 2</td><td>属性的默认值</td></tr></tbody></table><hr><h2 id="Vector-3"><a href="#Vector-3" class="headerlink" title="Vector 3"></a>Vector 3</h2><p>定义一个Vector 3 值。在材质检视面板中显示一个Vector 4 输入字段，其中不使用 w 分量。</p><table><thead><tr><th>数据类型</th><th>模式</th></tr></thead><tbody><tr><td>Vector 3</td><td></td></tr></tbody></table><table><thead><tr><th>字段</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>Default</td><td>Vector 3</td><td>属性的默认值</td></tr></tbody></table><hr><h2 id="Vector-4"><a href="#Vector-4" class="headerlink" title="Vector 4"></a>Vector 4</h2><p>定义一个Vector 4 值。在材质检视面板中显示一个Vector 4 输入字段。</p><table><thead><tr><th>数据类型</th><th>模式</th></tr></thead><tbody><tr><td>Vector 4</td><td></td></tr></tbody></table><table><thead><tr><th>字段</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>Default</td><td>Vector 4</td><td>属性的默认值</td></tr></tbody></table><hr><h2 id="Color"><a href="#Color" class="headerlink" title="Color"></a>Color</h2><p>定义一个Color 值。</p><table><thead><tr><th>数据类型</th><th>模式</th></tr></thead><tbody><tr><td>Color</td><td>Default、HDR</td></tr></tbody></table><h3 id="默认值-1"><a href="#默认值-1" class="headerlink" title="默认值"></a>默认值</h3><p>在材质检视面板中显示一个 sRGB 颜色字段。</p><table><thead><tr><th>字段</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>Default</td><td>Vector 4</td><td>属性的默认值</td></tr></tbody></table><h3 id="HDR"><a href="#HDR" class="headerlink" title="HDR"></a>HDR</h3><p>在材质检视面板中显示一个 HDR 颜色字段。</p><table><thead><tr><th>字段</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>Default</td><td>Vector 4</td><td>属性的默认值</td></tr></tbody></table><p>注意：在 10.0 之前的版本中，Shader Graph 未校正项目色彩空间的 HDR 颜色。10.0 版本更正了此行为。使用旧版本创建的 HDR<br>颜色属性仍保持旧行为，但可以使用 <a href="../ShaderGraph001/#GraphInspector">Graph Inspector</a><br>将其升级。要在伽马空间项目中模仿旧行为，可以使用 <a href="https://docs.unity3d.com/cn/Packages/com.unity.shadergraph@10.5/manual/Colorspace-Conversion-Node.html">Colorspace Conversion 节点</a><br>将新的 HDR颜色属性从 RGB 转换到 Linear 空间。</p><hr><h2 id="Texture-2D"><a href="#Texture-2D" class="headerlink" title="Texture 2D"></a>Texture 2D</h2><p>定义 Texture 2D 值。在材质检查器中显示“Texture”类型的对象字段。如果属性检查器显示<strong>Main“Main Texture”</strong><br>，则这是着色器的。要选择或取消选择此节点作为<br>，请在图形或 <a href="../ShaderGraph001/#Blackboard%E5%B1%9E%E6%80%A7%E9%9D%A2%E6%9D%BF">Blackboard</a> 中右键单击该节点，然后选择设置为<strong>Main Texture</strong>或<strong>Clear<br>Main Texture</strong>。对应于 <a href="https://docs.unity3d.com/Manual/SL-Properties.html">Main Texture</a> ShaderLab 属性。</p><table><thead><tr><th>数据类型</th><th>模式</th></tr></thead><tbody><tr><td>Texture</td><td>White(白色)、Black(黑色)、Grey(灰色)、Bump(凹凸)</td></tr></tbody></table><table><thead><tr><th>字段</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>Default</td><td>Texture</td><td>属性的默认值</td></tr><tr><td>Use Tiling and Offset(使用平铺和偏移)</td><td>布尔值 (Boolean)</td><td>设置为 false 时，激活属性NoScaleOffset，以便将比例和偏移量与其他纹理属性分开进行操作。看SplitTextureTransformNode.</td></tr></tbody></table><hr><h2 id="Texture-3D"><a href="#Texture-3D" class="headerlink" title="Texture 3D"></a>Texture 3D</h2><p>定义一个 Texture 3D值。在材质检视面板中显示一个 Texture 3D类型的对象字段。</p><table><thead><tr><th>数据类型</th><th>模式</th></tr></thead><tbody><tr><td>Texture</td><td></td></tr></tbody></table><table><thead><tr><th>字段</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>Default</td><td>Texture</td><td>属性的默认值</td></tr></tbody></table><hr><h2 id="Texture-2D-Array"><a href="#Texture-2D-Array" class="headerlink" title="Texture 2D Array"></a>Texture 2D Array</h2><p>定义 <a href="https://docs.unity3d.com/Manual/class-TextureImporter.html">Texture 2D Array</a> 值。在材质检查器中显示“纹理 2D<br>阵列”（Texture 2D Array） 类型的对象字段。</p><table><thead><tr><th>数据类型</th><th>模式</th></tr></thead><tbody><tr><td>Texture</td><td></td></tr></tbody></table><table><thead><tr><th>字段</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>Default</td><td>Texture</td><td>属性的默认值</td></tr></tbody></table><hr><h2 id="Cubemap-立方体贴图"><a href="#Cubemap-立方体贴图" class="headerlink" title="Cubemap(立方体贴图)"></a>Cubemap(立方体贴图)</h2><p>定义 <a href="https://docs.unity3d.com/Manual/class-Cubemap.html">Cubemap</a> 值。在材质检查器中显示“Texture”类型的对象字段。</p><table><thead><tr><th>数据类型</th><th>模式</th></tr></thead><tbody><tr><td>Cubemap</td><td></td></tr></tbody></table><table><thead><tr><th>字段</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>Default</td><td>Cubemap</td><td>属性的默认值</td></tr></tbody></table><hr><h2 id="Virtual-Texture-虚拟纹理"><a href="#Virtual-Texture-虚拟纹理" class="headerlink" title="Virtual Texture(虚拟纹理)"></a>Virtual Texture(虚拟纹理)</h2><p>定义一个<a href="https://docs.unity3d.com/2020.1/Documentation/Manual/svt-use-in-shader-graph.html">纹理堆栈</a>，在材质检视面板中显示为”Texture”类型的对象字段。字段数对应于属性中的层数。</p><table><thead><tr><th>数据类型</th><th>模式</th></tr></thead><tbody><tr><td>Virtual Texture</td><td></td></tr></tbody></table><table><thead><tr><th>字段</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>Default</td><td>Texture</td><td>属性的默认值</td></tr></tbody></table><hr><h2 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h2><p>定义 Boolean 值。在材料检查器中显示 ToggleUI 字段。请注意，在着色器内部，此值是** Float**。Shader Graph 中的 Boolean 类型只是为了可用性。</p><table><thead><tr><th>数据类型</th><th>模式</th></tr></thead><tbody><tr><td>Boolean</td><td></td></tr></tbody></table><table><thead><tr><th>字段</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>Default</td><td>Boolean</td><td>属性的默认值</td></tr></tbody></table><hr>]]></content>
      
      
      <categories>
          
          <category> ShaderGraph </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ShaderGraph </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ShaderGraph 界面介绍</title>
      <link href="//ShaderGraph/ShaderGraph001/"/>
      <url>//ShaderGraph/ShaderGraph001/</url>
      
        <content type="html"><![CDATA[<h2 id="MasterStack主栈"><a href="#MasterStack主栈" class="headerlink" title="MasterStack主栈"></a>MasterStack主栈</h2><p>主栈是 Shader Graph 的终点，用于定义着色器的最终表面外观。Shader Graph 应始终包含一个且仅包含一个主栈。<br>主栈包含两个上下文：</p><ol><li>Vertex 顶点着色器<br>连接到 Vertex Context 中的 <a href="#">Block</a> 的任何节点都将成为最终着色器的顶点函数的一部分</li><li>Fragment 片段着色器<br>连接到 Fragment Context 中的 <a href="#">Block</a> 的任何节点都将成为最终着色器的片元（或像素）函数的一部分</li></ol><blockquote><p>注意： 如果你将任何节点连接到两个上下文，它们将被执行两次，一次在顶点函数中，然后在片元函数中再次执行。上下文不能剪切、复制或粘贴</p></blockquote><h2 id="MainPreview预览窗口"><a href="#MainPreview预览窗口" class="headerlink" title="MainPreview预览窗口"></a>MainPreview预览窗口</h2><p>Main Preview 显示活动渲染管线上的着色器的一种表示结果。它会实时更新并自动更新以显示你在 Shader Graph 中所做的任何更改。Main Preview 的标题栏显示当前着色器的名称。</p><p>Main Preview 可移动到 Shader Graph 窗口中的任意位置，并将随该窗口的最近一个角自动移动。</p><ol><li>预览网格<br>可通过按住鼠标左键并拖动 Main Preview 来旋转预览网格，并可使用滚轮进行缩放。右键单击 Main Preview 可以更改预览网格。在此处可以选择任何原始网格类型或选择自定义网格。</li></ol><h2 id="Blackboard属性面板"><a href="#Blackboard属性面板" class="headerlink" title="Blackboard属性面板"></a>Blackboard属性面板</h2><p>你可以使用 Blackboard 对图形中的<a href="#">属性</a>和<a href="#">关键字</a>进行定义、排序和分类。在 Blackboard 中，你还可以编辑所选 Shader Graph 资源或Subgraph的路径。</p><ol><li>访问 Blackboard<br>默认情况下，Blackboard是可见的，你不能将其拖出图形并丢失它。但是，你可以将其放置在 Shader Graph Window 中的任何位置。它始终与最近的角保持相同的距离，即使你调整窗口大小也是如此。</li><li>向 Blackboard 添加属性和关键字<br>要创建新属性或关键字，请单击 Blackboard 标题栏上的添加 （+） 按钮，然后选择一种类型。有关属性类型的完整列表，请参阅<a href="#">属性类型</a>。</li><li>编辑<strong>属性</strong>和<strong>关键字</strong><br>选择黑板或图中的属性或关键字，以在节点设置菜单中修改其设置。</li></ol><table><thead><tr><th>设置</th><th>描述</th></tr></thead><tbody><tr><td>名称</td><td>属性的显示名称。编辑器会从显示名称中剥离引号并用下划线替换。通过在黑板上双击其名称来重命名项目。</td></tr><tr><td>引用</td><td>Shader Graph 内部使用的此属性的名称。虽然编辑器默认会填充此值，但你可以修改它。要还原为原始引用名称，右键点击引用（不是输入字段）并选择上下文菜单中的重置引用。如果引用名称包含 HLSL 不支持的任何字符，编辑器会用下划线替换这些字符。</td></tr><tr><td>默认值</td><td>基于此 Shader Graph 的任何材质中此属性的默认值。例如，如果你有一个草的 Shader Graph 并公开草的颜色作为属性，你可能会将默认值设置为绿色。</td></tr><tr><td>精度</td><td>设置属性的精度模式。见<a href="#">精度模式</a>。</td></tr><tr><td>暴露</td><td>启用此设置，使属性可供你通过 C# API 编辑。默认启用。</td></tr></tbody></table><ol start="4"><li><strong>修改</strong>和<strong>选择</strong>属性和关键字<ul><li>要对 Blackboard 上列出的项目重新排序，请拖放它们。</li><li>若要删除项目，请在 Windows 上使用 Delete 键或在 macOS 上使用 Command + Backspace 键。</li><li>要选择多个项目，请在进行选择时按住 Ctrl 键。</li><li>若要取消对一个或多个项目的选择，请按住 Ctrl 键，同时单击要从选择中删除的项目。</li></ul></li><li>使用 Blackboard 类别<br>若要使着色器中的属性更易于发现，请将它们组织成类别。展开和折叠类别以使 Blackboard 更易于导航。</li><li><strong>创建</strong>、<strong>重命名</strong>、<strong>移动</strong>和<strong>删除</strong>类别<ul><li>要添加类别，请在 Blackboard 上使用 +。</li><li>若要重命名类别，请双击类别名称，或右键单击并选择“重命名”。</li><li>要在 Blackboard 中移动类别，请选择并拖动该类别。</li><li>若要删除类别，请选择该类别并按 Delete 键，或右键单击并选择“删除”。删除类别也会删除其中的属性，因此请移动要保留的属性。</li></ul></li><li><strong>添加</strong>、<strong>删除</strong>和<strong>重新排序</strong>属性和关键字<ul><li>若要将属性或关键字添加到类别，请使用折叠 （⌄） 符号展开类别，然后将属性或关键字拖放到展开的类别上。</li><li>若要删除属性或关键字，请选择该属性或关键字并按 Delete，或右键单击并选择“删除”。</li><li>要对属性或关键字重新排序，请将它们拖放到某个类别中，或将它们移动到其他类别中。</li></ul></li><li>为<strong>特定属性</strong>和<strong>关键字</strong>创建类别<br>选择多个属性或关键字，然后在 Blackboard 上使用 + 创建一个包含你选择的所有项目的类别。</li><li><strong>复制</strong>和<strong>粘贴</strong>类别，带或不带属性    <ul><li>你可以将空类别、包含所有属性的类别以及包含部分属性的类别粘贴到一个或多个图形中。要复制具有所有属性的类别，请执行以下操作：<ul><li>选择属性。</li><li>使用 Ctrl+C 复制它。</li><li>使用 Ctrl+V 将其粘贴到目标图形中。</li></ul></li><li>要复制一组特定的属性，请执行以下操作：<ul><li>选择类别。</li><li>按住 Ctrl 键。</li><li>单击不想包含的属性以将其从选定内容中删除。</li><li>使用 Ctrl+C 复制属性。</li><li>使用 Ctrl+V 将其粘贴到目标图形中。</li></ul></li></ul></li><li>在材质检查器中使用类别<br>要修改使用 Shader Graph 创建的材质，可以在材质检查器中调整特定属性或关键字值，或编辑图形本身。<ul><li>使用流式处理虚拟纹理<br><a href="https://docs.unity3d.com/Manual/svt-use-in-shader-graph.html">流式处理虚拟纹理属性</a>示例纹理图层。要在材质检查器中访问这些图层，请展开相关的“虚拟纹理”部分，并在其名称旁边加上 ⌄ 符号。你可以通过检查器添加和移除图层。</li></ul></li><li>公开属性和关键字<br>Unity 默认会暴露属性和关键字。这允许你通过脚本进行写访问，以便你可以通过 C# API 编辑它们，除了图表之外。暴露的项目在其标签上有一个绿点。在节点设置菜单中启用或禁用此功能。</li><li>创建节点<br>将属性或关键字从 Blackboard 拖动到图形中，以创建此类节点。图形中节点的设置与 Blackboard 中相关属性或关键字的设置相同。展开这些节点以使用属性值的子成员。 如果属性已公开，则属性节点名称将包含一个绿点。</li></ol><h2 id="GraphInspector"><a href="#GraphInspector" class="headerlink" title="GraphInspector"></a>GraphInspector</h2><p>Graph Inspector使你能够与 <a href="#">Shader Graph 资源</a>的任何可选<strong>图形元素</strong>和<strong>图形范围设置</strong>进行交互。你可以使用 Graph Inspector 来编辑属性和默认值。<br>打开 Shader Graph 时，Graph Inspector 默认显示“<a href="#">Graph 设置</a>”选项卡。该特定Shader Graph的图形范围设置将显示在此选项卡中。</p><ul><li>如何使用<br>选择图形中的一个节点，以在Graph Inspector中显示该节点的可用设置。该节点的可用设置显示在 Graph Inspector 的“<strong>节点设置</strong>”选项卡中。例如，如果在图形或 <a href="#Blackboard%E5%B1%9E%E6%80%A7%E9%9D%A2%E6%9D%BF">Blackboard</a> 中选择属性节点，则“节点设置”选项卡将显示可编辑的属性属性。<ul><li>当前与 Graph Inspector 配合使用的图形元素：<ul><li><a href="https://docs.unity3d.com/Manual/SL-Properties.html">属性</a></li><li><a href="https://docs.unity3d.com/Packages/com.unity.shadergraph@17.0/manual/Keywords.html">关键字</a></li><li><a href="https://docs.unity3d.com/Packages/com.unity.shadergraph@17.0/manual/Sub-graph.html">自定义函数节点</a></li><li><a href="https://docs.unity3d.com/Packages/com.unity.shadergraph@17.0/manual/Sub-graph.html">Subgraph Output 节点</a></li><li><a href="https://docs.unity3d.com/cn/Packages/com.unity.shadergraph@10.5/manual/Precision-Types.html">每个节点的精度</a></li></ul></li><li>当前不适用于 Graph Inspector 的图形元素：<ul><li>边缘</li><li><a href="https://docs.unity3d.com/Packages/com.unity.shadergraph@17.0/manual/Sticky-Notes.html">便笺</a></li><li>组</li></ul></li></ul></li><li>材质覆盖<br>通过在“图形设置”<a href="https://docs.unity3d.com/Packages/com.unity.shadergraph@17.0/manual/surface-options.html">（Graph Settings） 中启用“允许材质覆盖”（Allow Material Override）</a> 选项，您可以通过“材质检查器”（Material Inspector） 覆盖某些图形属性</li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="标题栏"><a href="#标题栏" class="headerlink" title="标题栏"></a>标题栏</h3><p>Shader Graph 窗口顶部的标题栏包含可对图形执行的操作。</p><ul><li>Save Asset 保存图形以更新 Shader Graph 资源</li><li>Save As 打开一个文件对话框，允许用户以新名称保存 <a href="#">Shader Graph 资源</a>。</li><li>Show In Project 此时将在 Project 窗口中突出显示 <a href="#">Shader Graph 资源</a></li><li>Check Out 如果启用了版本控制，将从源代码控制提供商签出 <a href="#">Shader Graph 资源</a> 。</li><li>Color Mode 提供下拉菜单以选择图形的<a href="#">颜色模式</a>。</li><li>Blackboard 切换 <a href="#Blackboard%E5%B1%9E%E6%80%A7%E9%9D%A2%E6%9D%BF">Blackboard</a> 的可见性。</li><li>GraphInspector 切换 <a href="#GraphInspector">GraphInspector</a> 的可见性。</li><li>MainPreview 切换 <a href="#MainPreview%E9%A2%84%E8%A7%88%E7%AA%97%E5%8F%A3">MainPreview</a> 的可见性。</li></ul><h3 id="工作空间"><a href="#工作空间" class="headerlink" title="工作空间"></a>工作空间</h3><p>工作空间是创建<a href="#">节点</a>网络的地方。 要在工作空间中导航，可按住 Alt 和鼠标左键，使用滚轮进行平移和缩放。</p><p>可按住鼠标左键并拖动以使用选取框选择多个<a href="#">节点</a>。还有各种快捷键可用于改善工作流程。</p><table><thead><tr><th>热键</th><th>Windows</th><th>OSX</th><th>描述</th></tr></thead><tbody><tr><td>剪切</td><td>Ctrl + X</td><td>Command + X</td><td>将选定的<a href="#">节点</a>剪切到剪贴板</td></tr><tr><td>复制</td><td>Ctrl + C</td><td>Command + C</td><td>将选定的<a href="#">节点</a>复制到剪贴板</td></tr><tr><td>粘贴</td><td>Ctrl + V</td><td>Command + V</td><td>粘贴剪贴板中的<a href="#">节点</a></td></tr><tr><td>焦点</td><td>F</td><td>F</td><td>将工作空间聚焦在所有或选定的<a href="#">节点</a>上</td></tr><tr><td>创建节点</td><td>空格键</td><td>空格键</td><td>打开 Create Node Menu</td></tr></tbody></table><h3 id="上下文菜单"><a href="#上下文菜单" class="headerlink" title="上下文菜单"></a>上下文菜单</h3><p>在工作空间内单击右键将打开上下文菜单。请注意，右键单击工作空间中的某一项（例如<a href="#">节点</a>）将打开该项的上下文菜单，而不是工作空间。</p><table><thead><tr><th>项</th><th>描述</th></tr></thead><tbody><tr><td>创建节点</td><td>打开 Create Node Menu</td></tr><tr><td>Create</td><td>Sticky Note在图形上创建一个新的即时贴。</td></tr><tr><td>Collapse</td><td>All Previews折叠所有<a href="#">节点</a>上的预览</td></tr><tr><td>剪切</td><td>将选定的<a href="#">节点</a>剪切到剪贴板</td></tr><tr><td>复制</td><td>将选定的<a href="#">节点</a>复制到剪贴板</td></tr><tr><td>粘贴</td><td>粘贴剪贴板中的<a href="#">节点</a></td></tr><tr><td>Delete</td><td>删除选定的<a href="#">节点</a></td></tr><tr><td>Duplicate</td><td>复制选定的<a href="#">节点</a></td></tr><tr><td>Select &#x2F; Unused Nodes</td><td>从主栈选择图形中所有对最终着色器输出没有贡献的<a href="#">节点</a></td></tr><tr><td>View &#x2F; Collapse Ports</td><td>折叠所有选定<a href="#">节点</a>上未使用的端口</td></tr><tr><td>View &#x2F; Expand Ports</td><td>展开所有选定<a href="#">节点</a>上未使用的端口</td></tr><tr><td>View &#x2F; Collapse Previews</td><td>折叠所有选定<a href="#">节点</a>上的预览</td></tr><tr><td>View &#x2F; Expand Previews</td><td>展开所有选定<a href="#">节点</a>上的预览</td></tr><tr><td>Precision &#x2F; Inherit</td><td>将所有选定<a href="#">节点</a>的精度设置为 Inherit</td></tr><tr><td>Precision &#x2F; Float</td><td>将所有选定<a href="#">节点</a>的精度设置为 Float</td></tr><tr><td>Precision &#x2F; Half</td><td>将所有选定<a href="#">节点</a>的精度设置为 Half</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> ShaderGraph </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ShaderGraph </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ShaderGraph 学习大纲</title>
      <link href="//ShaderGraph/ShaderGraph000/"/>
      <url>//ShaderGraph/ShaderGraph000/</url>
      
        <content type="html"><![CDATA[<h3 id="关于-Shader-Graph"><a href="#关于-Shader-Graph" class="headerlink" title="关于 Shader Graph"></a>关于 Shader Graph</h3><p>Shader Graph 能够让您直观地构建着色器。您可以在图形框架中创建并连接节点，而不必手写代码。Shader Graph<br>提供了能反映所作更改的即时反馈，对于不熟悉着色器创建的用户来说非常简单。</p><p>整理中……待续</p><h1 id="ShaderGraph学习大纲"><a href="#ShaderGraph学习大纲" class="headerlink" title="ShaderGraph学习大纲"></a>ShaderGraph学习大纲</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><ul><li><a href="/ShaderGraph/ShaderGraph001/" title="ShaderGraph 界面介绍">ShaderGraph 界面介绍</a></li><li><a href="/ShaderGraph/ShaderGraph002/" title="ShaderGraph 属性类型">ShaderGraph 属性类型</a></li><li><a href="/ShaderGraph/ShaderGraph003/" title="ShaderGraph 数据类型">ShaderGraph 数据类型</a></li><li><a href="/ShaderGraph/ShaderGraph004/" title="ShaderGraph 关键字">ShaderGraph 关键字</a></li></ul><h2 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h2><ul><li><a href="/ShaderGraph/ShaderGraph100/" title="ShaderGraph节点学习">ShaderGraph节点学习</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> ShaderGraph </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ShaderGraph </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4399冒险大作战(开宝箱+史莱姆like)</title>
      <link href="//Gameplay/Gameplay002/"/>
      <url>//Gameplay/Gameplay002/</url>
      
        <content type="html"><![CDATA[<p>冒险大作战(微信小游戏)深度体验报告,前期玩法师后期转风弩手 等级:120 神灯等级:25 战力:30356.4K</p><h1 id="主界面底部"><a href="#主界面底部" class="headerlink" title="主界面底部"></a>主界面底部</h1><h2 id="底部栏"><a href="#底部栏" class="headerlink" title="底部栏"></a>底部栏</h2><h3 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h3><h4 id="职业"><a href="#职业" class="headerlink" title="职业"></a>职业</h4><ul><li>有3个职业，每个职业2个不同分支。</li><li>一个主动技能，5个被动技能（根据等级解锁）</li><li>觉醒6个槽位之后,主动技能变化;</li></ul><h4 id="技能"><a href="#技能" class="headerlink" title="技能"></a>技能</h4><ul><li>5个佩戴技能自由搭配，有方案切换，技能能延迟释放。</li><li>技能通过<a href="#%E5%95%86%E5%BA%97">商店</a>，技能抽奖获的先解锁，后获得碎片升级。</li><li>技能有拥有属性，解锁越多属性越高。</li><li>技能有佩戴属性，穿戴加成。</li><li>技能满级后能合成高一级的技能碎片。</li><li>技能等级：白、绿、蓝、紫、黄、橙、红、粉</li></ul><h4 id="职业觉醒"><a href="#职业觉醒" class="headerlink" title="职业觉醒"></a>职业觉醒</h4><ul><li>120级别解锁</li><li>通过消耗<a href="#%E7%AB%9E%E6%8A%80%E5%9C%BA">觉醒水晶</a>随机觉醒一个属性。</li><li>攻击、生命、防御、暴伤、抗暴、普攻。</li><li>觉醒后消耗<a href="#%E8%B7%A8%E6%9C%8D%E6%8E%92%E4%BD%8D%E8%B5%9B">觉醒卷轴</a>升级。</li></ul><h3 id="同伴"><a href="#同伴" class="headerlink" title="同伴"></a>同伴</h3><ul><li>5个上阵伙伴自由搭配，有方案切换。</li><li>伙伴通过<a href="#%E5%95%86%E5%BA%97">商店</a>，伙伴抽奖获的先解锁，后获得碎片升级。</li><li>伙伴有拥有属性，解锁越多属性越高。</li><li>伙伴有上阵属性，上阵加成。</li><li>伙伴满级后能合成高一级的技能碎片。</li><li>不同伙伴有不同的伤害系数和攻击速度。</li><li>伙伴等级：白、绿、蓝、紫、黄、橙、红、粉</li></ul><h3 id="副本"><a href="#副本" class="headerlink" title="副本"></a>副本</h3><ul><li>材料副本都可以通过看广告来增加2次副本次数。</li><li>记录最高次数</li><li>扫荡最高记录</li></ul><h4 id="深渊之门"><a href="#深渊之门" class="headerlink" title="深渊之门"></a>深渊之门</h4><ul><li>类似世界Boss，固定每个小时前20分钟能打，每只不同属性的词条</li><li>每天结算排名发奖励，<a href="#%E7%A7%8D%E5%9C%B0">种子</a>、<a href="#%E7%A5%9E%E5%99%A8">神威锤</a>、<a href="#%E6%AD%A6%E9%AD%82">武魂精华</a></li></ul><h4 id="神灯副本"><a href="#神灯副本" class="headerlink" title="神灯副本"></a>神灯副本</h4><ul><li><a href="#%E7%A5%9E%E7%81%AF">神灯</a>产出</li></ul><h4 id="冰龙副本"><a href="#冰龙副本" class="headerlink" title="冰龙副本"></a>冰龙副本</h4><ul><li>钻石货币、技能抽奖卷、伙伴抽奖卷</li></ul><h4 id="遗物副本"><a href="#遗物副本" class="headerlink" title="遗物副本"></a>遗物副本</h4><ul><li><a href="#%E9%81%97%E7%89%A9">遗物碎片</a>产出</li><li>随机匹配或邀请好友，多人副本</li></ul><h4 id="坐骑材料"><a href="#坐骑材料" class="headerlink" title="坐骑材料"></a>坐骑材料</h4><ul><li><a href="#%E5%9D%90%E9%AA%91">无限时发条</a> 材料产出</li><li>通关5个小关，boss没打死主角死了也算次数。</li></ul><h4 id="神器附魔材料副本"><a href="#神器附魔材料副本" class="headerlink" title="神器附魔材料副本"></a>神器附魔材料副本</h4><ul><li>前期打不过，后面战力上来才能开始打的副本</li><li><a href="#%E7%A5%9E%E5%99%A8">符石</a>不同级别掉落</li></ul><h4 id="试炼副本"><a href="#试炼副本" class="headerlink" title="试炼副本"></a>试炼副本</h4><ul><li><a href="#%E5%85%85%E5%80%BC%E5%A5%BD%E7%A4%BC">试炼特权卡</a>和<a href="#%E5%85%85%E5%80%BC%E5%A5%BD%E7%A4%BC">终身卡</a>，能多一些奖励，多一次挑战奖励</li><li><a href="#%E8%83%8C%E9%A5%B0">羽币</a>和<a href="#%E8%83%8C%E9%A5%B0">神羽币</a> 产出</li></ul><h4 id="飞宠副本"><a href="#飞宠副本" class="headerlink" title="飞宠副本"></a>飞宠副本</h4><ul><li>爬塔获取奖励，结算奖励</li><li><a href="#%E9%A3%9E%E5%AE%A0">飞宠蛋</a>、其他飞宠材料、飞宠进阶材料，也能选择其他道具</li></ul><h3 id="家园"><a href="#家园" class="headerlink" title="家园"></a>家园</h3><h4 id="种地"><a href="#种地" class="headerlink" title="种地"></a>种地</h4><h3 id="家族"><a href="#家族" class="headerlink" title="家族"></a>家族</h3><h3 id="商店"><a href="#商店" class="headerlink" title="商店"></a>商店</h3><h2 id="主线任务"><a href="#主线任务" class="headerlink" title="主线任务"></a>主线任务</h2><h2 id="物品栏"><a href="#物品栏" class="headerlink" title="物品栏"></a>物品栏</h2><h3 id="装备"><a href="#装备" class="headerlink" title="装备"></a>装备</h3><h3 id="坐骑"><a href="#坐骑" class="headerlink" title="坐骑"></a>坐骑</h3><h3 id="神器"><a href="#神器" class="headerlink" title="神器"></a>神器</h3><h3 id="遗物"><a href="#遗物" class="headerlink" title="遗物"></a>遗物</h3><h3 id="武魂"><a href="#武魂" class="headerlink" title="武魂"></a>武魂</h3><h3 id="背饰"><a href="#背饰" class="headerlink" title="背饰"></a>背饰</h3><h3 id="戒指"><a href="#戒指" class="headerlink" title="戒指"></a>戒指</h3><h3 id="飞宠"><a href="#飞宠" class="headerlink" title="飞宠"></a>飞宠</h3><h3 id="航海SLG"><a href="#航海SLG" class="headerlink" title="航海SLG"></a>航海SLG</h3><h2 id="神灯"><a href="#神灯" class="headerlink" title="神灯"></a>神灯</h2><h2 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h2><h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><h1 id="主界面上半部分左边"><a href="#主界面上半部分左边" class="headerlink" title="主界面上半部分左边"></a>主界面上半部分左边</h1><h3 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h3><h3 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h3><h3 id="日程"><a href="#日程" class="headerlink" title="日程"></a>日程</h3><h3 id="跨服战"><a href="#跨服战" class="headerlink" title="跨服战"></a>跨服战</h3><h3 id="竞技场"><a href="#竞技场" class="headerlink" title="竞技场"></a>竞技场</h3><h4 id="竞技场-1"><a href="#竞技场-1" class="headerlink" title="竞技场"></a>竞技场</h4><h4 id="跨服排位赛"><a href="#跨服排位赛" class="headerlink" title="跨服排位赛"></a>跨服排位赛</h4><h3 id="游戏圈"><a href="#游戏圈" class="headerlink" title="游戏圈"></a>游戏圈</h3><h1 id="主界面上半部分右边"><a href="#主界面上半部分右边" class="headerlink" title="主界面上半部分右边"></a>主界面上半部分右边</h1><h2 id="放置奖励-离线经验"><a href="#放置奖励-离线经验" class="headerlink" title="放置奖励(离线经验)"></a>放置奖励(离线经验)</h2><h2 id="活动"><a href="#活动" class="headerlink" title="活动"></a>活动</h2><h3 id="充值好礼"><a href="#充值好礼" class="headerlink" title="充值好礼"></a>充值好礼</h3><h3 id="冲榜活动"><a href="#冲榜活动" class="headerlink" title="冲榜活动"></a>冲榜活动</h3><h3 id="限时礼包"><a href="#限时礼包" class="headerlink" title="限时礼包"></a>限时礼包</h3><h3 id="菇菇武道会-120级开"><a href="#菇菇武道会-120级开" class="headerlink" title="菇菇武道会(120级开)"></a>菇菇武道会(120级开)</h3><h3 id="每日消费-限时活动"><a href="#每日消费-限时活动" class="headerlink" title="每日消费(限时活动)"></a>每日消费(限时活动)</h3><h3 id="累计消费-限时活动"><a href="#累计消费-限时活动" class="headerlink" title="累计消费(限时活动)"></a>累计消费(限时活动)</h3><h3 id="主题活动-任务卡（限时活动）"><a href="#主题活动-任务卡（限时活动）" class="headerlink" title="主题活动+任务卡（限时活动）"></a>主题活动+任务卡（限时活动）</h3><h3 id="菇菇机-限时活动"><a href="#菇菇机-限时活动" class="headerlink" title="菇菇机(限时活动)"></a>菇菇机(限时活动)</h3><h3 id="招财猫-限时活动"><a href="#招财猫-限时活动" class="headerlink" title="招财猫(限时活动)"></a>招财猫(限时活动)</h3><h3 id="返利宝箱"><a href="#返利宝箱" class="headerlink" title="返利宝箱"></a>返利宝箱</h3>]]></content>
      
      
      <categories>
          
          <category> 游戏体验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏体验 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动物性格测试</title>
      <link href="//Knowledge/Knowledge001/"/>
      <url>//Knowledge/Knowledge001/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最著名的是“动物性格测试”（Animal Personality Test），它是一种心理测试工具，用于帮助人们了解自己的性格特点和行为倾向。</p><p>这种理论通常将人的性格分为几种动物类型，每种动物代表一种性格特征。以下是这四种动物性格的一般描述：</p><ol><li><p><strong>老虎（支配型）</strong>：老虎代表的是支配型性格，这类人通常自信、果断、有领导力，喜欢控制和领导他人，追求成功和成就。</p></li><li><p><strong>孔雀（表现型）</strong>：孔雀代表的是表现型性格，这类人外向、热情、善于社交，喜欢成为注意的焦点，追求认可和赞赏。</p></li><li><p><strong>猫头鹰（思考型）</strong>：猫头鹰代表的是思考型性格，这类人内向、分析、逻辑性强，喜欢思考和解决问题，追求知识和真理。</p></li><li><p><strong>考拉（稳定型）</strong>：考拉代表的是稳定型性格，这类人温和、耐心、可靠，喜欢稳定和和谐，追求安全和舒适。</p></li></ol><p>这种分类方式有助于个人了解自己的性格优势和潜在的改进空间，也可以用于团队建设和人际关系的改善。</p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>老虎、孔雀、猫头鹰、考拉这四种动物与人物性格的对应关系，属于一种非正式的、非科学的分类知识，通常用于商业和个人发展领域。这种分类知识并不是心理学领域中的正式理论，而是一种简化的性格分类方法，它借鉴了动物的某些特征来描述人类的性格类型。</p><p>以上动物性格分类方法，通常在以下情境中使用：</p><ol><li><p><strong>团队建设</strong>：在工作场所，了解团队成员的性格类型可以帮助优化团队组合，提高团队合作效率。</p></li><li><p><strong>个人发展</strong>：个人可以通过了解自身的性格特点来制定职业发展计划，或在个人生活中做出更好的决策。</p></li><li><p><strong>教育培训</strong>：教育者可以利用性格分类来识别学生的学习风格，从而提供个性化的教学方法。</p></li><li><p><strong>销售和市场营销</strong>：在销售和市场营销中，了解客户的性格类型可以帮助销售人员更有效地与客户沟通，提供定制化的服务。</p></li><li><p><strong>人力资源管理</strong>：在招聘和员工发展中，性格分类可以帮助人力资源部门匹配合适的职位和员工，以及设计培训计划。</p></li><li><p><strong>心理咨询</strong>：虽然这不是心理学的主流方法，但某些心理咨询师可能会使用这种分类来帮助客户更好地了解自己，作为更深入心理分析的起点。</p></li><li><p><strong>社交互动</strong>：在社交场合，了解不同人的性格类型可以帮助人们更好地与他人建立联系和沟通。</p></li><li><p><strong>自我认知</strong>：作为一种自我探索的工具，性格分类可以帮助人们更深入地了解自己的优势和弱点。</p></li><li><p><strong>娱乐和趣味</strong>：性格测试也可以作为一种娱乐活动，让人们在轻松的氛围中了解和讨论性格。</p></li><li><p><strong>沟通技巧提升</strong>：了解不同性格类型可以帮助提升个人的沟通技巧，更好地与不同性格的人相处。</p></li></ol><p>尽管这种分类方法在某些情况下有用，但它不应被视为一个全面的解决方案。在实际应用中，应当结合其他更科学的性格分析工具和方法，以及个人的具体情况来使用。</p>]]></content>
      
      
      <categories>
          
          <category> 小知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小知识 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
